C51 COMPILER V9.60.7.0   UART0                                                             11/28/2024 14:06:58 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE UART0
OBJECT MODULE PLACED IN .\Release\Objects\uart0.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\Hardware\uart0.c LARGE OPTIMIZE(8,SIZE) BROWSE INTVECTOR(0X000C) I
                    -NCDIR(..\..\Libraries\Include;..\..\User;..\..\User\lib;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\L
                    -istings\uart0.lst) OBJECT(.\Release\Objects\uart0.obj)

line level    source

   1          #include "uart0.h"
   2          
   3          #include <string.h> // memset()
   4          
   5          // ËÆæÁΩÆÁöÑÊ≥¢ÁâπÁéáÈúÄË¶ÅÈÄÇÈÖçÂçïÁâáÊú∫ÁöÑÊó∂ÈíüÔºåËøôÈáåÁõ¥Êé•‰ΩøÁî®‰∫ÜÂÆòÊñπÁöÑ‰ª£Á†Å
   6          #define USER_UART0_BAUD ((SYSCLK - UART0_BAUDRATE) / (UART0_BAUDRATE))
   7          
   8          // Áî®Êù•Â≠òÊîæÊé•Êî∂ÁöÑÊï∞ÊçÆÂ∏ßÁöÑÁºìÂÜ≤Âå∫
   9          volatile u8 uart0_recv_buf[(UART0_RXBUF_LEN) / (FRAME_MAX_LEN)][FRAME_MAX_LEN] = {0};
  10          // Áî®‰∫éËÆ∞ÂΩïÊé•Êî∂ÁºìÂÜ≤Âå∫ÁöÑÂØπÂ∫îÁöÑÊï∞ÊçÆÂ∏ßÁöÑÈïøÂ∫¶
  11          volatile u8 uart0_recv_len[(UART0_RXBUF_LEN) / (FRAME_MAX_LEN)] = {0};
  12          // ËÆ∞ÂΩïÁºìÂÜ≤Âå∫‰∏≠ÂØπÂ∫îÁöÑ‰ΩçÁΩÆÊòØÂê¶ÊúâÊï∞ÊçÆÁöÑÊ†áÂøó‰ΩçÔºàÊï∞ÁªÑÔºâ
  13          // ‰æãÂ¶ÇÔºåÁºìÂÜ≤Âå∫‰∏ãÊ†á0ÁöÑ‰ΩçÁΩÆÊúâÊåá‰ª§ÔºåÊ†áÂøó‰ΩçÊï∞ÁªÑ‰∏ãÊ†á0ÁöÑÂÖÉÁ¥†ÂÄº‰∏∫1ÔºåÊ≤°ÊúâÊåá‰ª§ÔºåÂ
             -ÖÉÁ¥†ÁöÑÂÄº‰∏∫0
  14          volatile u8 recved_flagbuf[(UART0_RXBUF_LEN) / (FRAME_MAX_LEN)] = {0};
  15          
  16          volatile u8 flagbuf_valid_instruction[(UART0_RXBUF_LEN) / (FRAME_MAX_LEN)] = {0}; // Â≠òÊîæÊúâÂêàÊ≥ïÊåá‰ª§
             -ÁöÑÊ†áÂøó‰ΩçÊï∞ÁªÑ
  17          
  18          // ‰∏≤Âè£‰∏≠Êñ≠ÊúçÂä°ÂáΩÊï∞‰∏≠ÔºåÊé•Êî∂‰∏ÄÂ∏ßÁöÑÊ†áÂøó‰ΩçÔºå0--ÂáÜÂ§áÊé•Êî∂‰∏ÄÂ∏ßÁöÑÁ¨¨‰∏Ä‰∏™Â≠óËäÇÔºå1--Ê
             -≠£Âú®Êé•Êî∂ËØ•Â∏ßÁöÑÊï∞ÊçÆ
  19          static volatile bit flag_is_recving_data = 0;
  20          static volatile u8 frame_len = 0;    // ËÆ∞ÂΩï‰∏≤Âè£‰∏≠Êñ≠ÊúçÂä°ÂáΩÊï∞‰∏≠ÔºåÂΩìÂâçË¶ÅÊé•Êî∂ÁöÑÊï∞ÊçÆÂ∏ßÁöÑ
             -Â≠óËäÇÊï∞
  21          static volatile u8 cur_recv_len = 0; // ËÆ∞ÂΩï‰∏≤Âè£‰∏≠Êñ≠ÊúçÂä°ÂáΩÊï∞‰∏≠ÔºåÂΩìÂâçÂ∑≤Êé•Êî∂ÁöÑÊï∞ÊçÆÂ∏ßÁöÑ
             -Â≠óËäÇÊï∞
  22          volatile u8 recv_frame_cnt = 0;      // Êé•Êî∂Âà∞ÁöÑÊï∞ÊçÆÂ∏ßÁöÑ‰∏™Êï∞
  23          
  24          static volatile u32 blank_index = 0; // ËÆ∞ÂΩïÂΩìÂâçÂ≠òÊîæÊï∞ÊçÆÂ∏ßÁöÑÁºìÂÜ≤Âå∫ÁöÑÁ©∫ÁöÑÂú∞Êñπ(ÁºìÂÜ≤Âå∫‰∏
             -ãÊ†á)ÔºåÂáÜÂ§áÂ≠òÊîæ‰∏ÄÂ∏ßÁöÑÊï∞ÊçÆ
  25          
  26          // bit test_bit = 0; // ÊµãËØïÁî®
  27          
  28          // u32 test_val = 0; // ÊµãËØïÁî®
  29          
  30          // ÈáçÂÜôputchar()ÂáΩÊï∞
  31          char putchar(char c)
  32          {
  33   1          uart0_sendbyte(c);
  34   1          return c;
  35   1      }
  36          
  37          // uart0ÂàùÂßãÂåñ
  38          // Ê≥¢ÁâπÁéáÁî±ÂÆè UART0_BAUDRATE Êù•ÂÜ≥ÂÆö
  39          void uart0_config(void)
  40          {
  41   1          // ÁîµË∑ØÊùø‰∏äÔºåP11‰∏∫ÂèëÈÄÅÂºïËÑöÔºåP12‰∏∫Êé•Êî∂ÂºïËÑö
  42   1          P1_MD0 &= (~GPIO_P11_MODE_SEL(0x3) | ~GPIO_P12_MODE_SEL(0x3));
  43   1          P1_MD0 |= GPIO_P11_MODE_SEL(0x1); // ËæìÂá∫Ê®°Âºè
  44   1          FOUT_S11 |= GPIO_FOUT_UART0_TX;   // ÈÖçÁΩÆP11‰∏∫UART0_TX
  45   1          FIN_S7 |= GPIO_FIN_SEL_P12;       // ÈÖçÁΩÆP12‰∏∫UART0_RX
  46   1      
  47   1          __EnableIRQ(UART0_IRQn); // ÊâìÂºÄUARTÊ®°Âùó‰∏≠Êñ≠
C51 COMPILER V9.60.7.0   UART0                                                             11/28/2024 14:06:58 PAGE 2   

  48   1          IE_EA = 1;               // ÊâìÂºÄÊÄª‰∏≠Êñ≠
  49   1      
  50   1          UART0_BAUD1 = (USER_UART0_BAUD >> 8) & 0xFF; // ÈÖçÁΩÆÊ≥¢ÁâπÁéáÈ´òÂÖ´‰Ωç
  51   1          UART0_BAUD0 = USER_UART0_BAUD & 0xFF;        // ÈÖçÁΩÆÊ≥¢ÁâπÁéá‰ΩéÂÖ´‰Ωç
  52   1          UART0_CON0 = UART_STOP_BIT(0x0) |
  53   1                       UART_RX_IRQ_EN(0x1) |
  54   1                       UART_EN(0x1); // 8bitÊï∞ÊçÆÔºå1bitÂÅúÊ≠¢‰ΩçÔºå‰ΩøËÉΩRX‰∏≠Êñ≠
  55   1      
  56   1          // memset(uart0_recv_buf, 0, sizeof(uart0_recv_buf));
  57   1      }
  58          
  59          // UART0‰∏≠Êñ≠ÊúçÂä°ÂáΩÊï∞ÔºàÊé•Êî∂‰∏≠Êñ≠Ôºâ
  60          void UART0_IRQHandler(void) interrupt UART0_IRQn
  61          {
  62   1          volatile u8 uart0_tmp_val = 0;
  63   1      
  64   1          // ËøõÂÖ•‰∏≠Êñ≠ËÆæÁΩÆIPÔºå‰∏çÂèØÂà†Èô§
  65   1          __IRQnIPnPush(UART0_IRQn);
  66   1          // ---------------- Áî®Êà∑ÂáΩÊï∞Â§ÑÁêÜ -------------------
  67   1          // RXÊé•Êî∂ÂÆåÊàê‰∏≠Êñ≠
  68   1          if (UART0_STA & UART_RX_DONE(0x1))
  69   1          {
  70   2              // test_bit = 1;
  71   2              uart0_tmp_val = UART0_DATA; // ‰∏¥Êó∂Â≠òÊîæÊé•Êî∂Âà∞ÁöÑÊï∞ÊçÆ
  72   2      
  73   2              if ((0 == flag_is_recving_data && uart0_tmp_val != 0xA5) ||
  74   2                  (recv_frame_cnt >= ((UART0_RXBUF_LEN) / (FRAME_MAX_LEN))))
  75   2              {
  76   3                  // 1. Â¶ÇÊûúÊòØÊñ∞ÁöÑ‰∏ÄÂ∏ßÊï∞ÊçÆÔºåÂç¥‰∏çÊòØ‰ª•0xA5ÂºÄÂ§¥ÔºåËØ¥ÊòéËøô‰∏ÄÂ∏ßÊï∞ÊçÆÊó†Êïà
  77   3                  // 2. Â¶ÇÊûúÁºìÂÜ≤Âå∫Â∑≤Êª°ÔºåÂ≠ò‰∏ç‰∏ãÊõ¥Â§öÁöÑÊï∞ÊçÆÂ∏ß
  78   3                  // Áõ¥Êé•ÈÄÄÂá∫‰∏≠Êñ≠Ôºå‰∏çÂ§ÑÁêÜÊï∞ÊçÆ
  79   3                  tmr0_disable();
  80   3                  tmr0_cnt = 0;
  81   3                  __IRQnIPnPop(UART0_IRQn);
  82   3                  return;
  83   3              }
  84   2              // if ((0 == flag_is_recving_data && UART0_DATA == 0xA5) ||
  85   2              //     (1 == flag_is_recving_data && UART0_DATA == 0xA5))
  86   2              else if (uart0_tmp_val == 0xA5)
  87   2              {
  88   3                  // 1. Â¶ÇÊûúÊòØÊñ∞ÁöÑ‰∏ÄÂ∏ßÊï∞ÊçÆÔºà‰ª•Ê†ºÂºèÂ§¥0xA5ÂºÄÂßãÔºâÔºåÊâìÂºÄÂÆöÊó∂Âô®Ôºå‰∏∫Ë∂ÖÊó∂Âà§
             -Êñ≠ÂÅöÂáÜÂ§á
  89   3                  // 2. Â¶ÇÊûúÊ≠£Âú®Êé•Êî∂‰∏ÄÂ∏ßÊï∞ÊçÆÔºåÂç¥ÂèàÊî∂Âà∞‰∫Ü‰∏ÄÊ¨°Ê†ºÂºèÂ§¥ÔºåËàçÂºÉ‰πãÂâçÊî∂Âà∞ÁöÑÊ
             -ï∞ÊçÆÔºåÈáçÊñ∞Êé•Êî∂Ëøô‰∏ÄÂ∏ß
  90   3                  flag_is_recving_data = 1;
  91   3                  cur_recv_len = 0;
  92   3                  frame_len = 0;
  93   3                  tmr0_disable();
  94   3                  tmr0_cnt = 0;
  95   3                  tmr0_enable();
  96   3              }
  97   2      
  98   2              if (1 == cur_recv_len)
  99   2              {
 100   3                  // Â¶ÇÊûúÊé•Êî∂Âà∞‰∏ÄÂ∏ßÁöÑÁ¨¨‰∫å‰∏™Â≠óËäÇÁöÑÊï∞ÊçÆÔºåËÆ∞ÂΩï‰∏ãË¶ÅÊé•Êî∂ÁöÑÊï∞ÊçÆÈïøÂ∫¶
 101   3                  frame_len = uart0_tmp_val;
 102   3                  // test_val = frame_len;
 103   3                  // printf("frame_len %d\n", (int32)frame_len);
 104   3              }
 105   2      
 106   2              // Á®ãÂ∫èËøêË°åÂà∞ËøôÈáåÔºåËØ¥ÊòéÊ≠£Âú®Êé•Êî∂‰∏Ä‰∏™Êï∞ÊçÆÂ∏ß
 107   2              if (0 == recved_flagbuf[blank_index])
C51 COMPILER V9.60.7.0   UART0                                                             11/28/2024 14:06:58 PAGE 3   

 108   2              {
 109   3                  // Â¶ÇÊûúÁºìÂÜ≤Âå∫‰∏≠ÊúâÂâ©‰Ωô‰ΩçÁΩÆÊù•Â≠òÊîæ‰∏Ä‰∏™Â∏ßÔºåÊâçÊîæÂÖ•Êï∞ÊçÆ
 110   3                  uart0_recv_buf[blank_index][cur_recv_len++] = uart0_tmp_val;
 111   3                  // uart0_recv_buf[0][cur_recv_len++] = UART0_DATA; // ÊµãËØïÁî®
 112   3                  tmr0_cnt = 0; // ÊØèÊé•Êî∂Âà∞‰∏Ä‰∏™Â≠óËäÇÊï∞ÊçÆÔºåÊ∏ÖÁ©∫Ë∂ÖÊó∂ÁöÑËÆ°Êó∂
 113   3      
 114   3      #if 1
 115   3                  if ((frame_len != 0) &&
 116   3                      (cur_recv_len) == frame_len)
 117   3                  {
 118   4                      // Â¶ÇÊûúÊé•Êî∂ÂÆå‰∫Ü‰∏ÄÂ∏ßÊï∞ÊçÆ
 119   4                      uart0_recv_len[blank_index] = frame_len; // Êõ¥Êñ∞ÂΩìÂâçÊï∞ÊçÆÂ∏ßÁöÑÈïøÂ∫¶
 120   4                      // printf("frame_len %d\n", (int32)frame_len);
 121   4                      flag_is_recving_data = 0; // Ê†áÂøó‰ΩçÊ∏ÖÈõ∂ÔºåÂáÜÂ§áÊé•Êî∂‰∏ã‰∏ÄÂ∏ßÊï∞ÊçÆ
 122   4                      cur_recv_len = 0;
 123   4                      frame_len = 0;
 124   4      
 125   4                      recved_flagbuf[blank_index] = 1; // ÂØπÂ∫îÁöÑÊé•Êî∂ÂÆåÊàêÊ†áÂøó‰ΩçÁΩÆ‰∏Ä
 126   4                      recv_frame_cnt++;                // Êé•Êî∂Âà∞ÂÆåÊï¥ÁöÑ‰∏ÄÂ∏ßÔºåËÆ°Êï∞ÂÄºÂä†‰∏Ä
 127   4                      // test_bit = 1; // ÊµãËØïÁî®
 128   4                      blank_index++;
 129   4                      if (blank_index >= ((UART0_RXBUF_LEN) / (FRAME_MAX_LEN)))
 130   4                      {
 131   5                          blank_index = 0;
 132   5                      }
 133   4      
 134   4                      // if (recv_frame_cnt < ((UART0_RXBUF_LEN) / (FRAME_MAX_LEN)))
 135   4                      // {
 136   4                      //     // Â¶ÇÊûúÊï∞ÁªÑ‰∏≠ÊúâÁ©∫‰ΩçÔºàÊé•Êî∂ÁöÑÊï∞ÊçÆÂ∏ß‰∏™Êï∞ < ÁºìÂÜ≤Âå∫ÊÄªÂÖ±ËÉΩÊé•Êî∂Áö
             -ÑÊï∞ÊçÆÂ∏ß‰∏™Êï∞Ôºâ
 137   4      
 138   4                      //     // ÂÅèÁßªÂà∞Êï∞ÁªÑ‰∏≠Á©∫ÁöÑÂú∞ÊñπÔºåÂáÜÂ§áÂ°´ÂÖ•‰∏ã‰∏Ä‰∏™Êï∞ÊçÆÂ∏ß
 139   4                      //     while (1)
 140   4                      //     {
 141   4                      //         blank_index++;
 142   4      
 143   4                      //         if (blank_index >= ((UART0_RXBUF_LEN) / (FRAME_MAX_LEN)))
 144   4                      //         {
 145   4                      //             // Â¶ÇÊûú‰∏ãÊ†áË∂ÖÂá∫‰∫ÜÁºìÂÜ≤Âå∫ËÉΩÂÆπÁ∫≥ÁöÑÊåá‰ª§‰∏™Êï∞
 146   4                      //             blank_index = 0;
 147   4                      //         }
 148   4      
 149   4                      //         if (0 == recved_flagbuf[blank_index])
 150   4                      //         {
 151   4                      //             // Â¶ÇÊûúÊòØÁ©∫ÁöÑ‰∏ÄÂ§ÑÁºìÂÜ≤Âå∫ÔºåÈÄÄÂá∫ÔºåÂáÜÂ§áÁªô‰∏ã‰∏ÄÊ¨°Êé•Êî∂Êï∞ÊçÆ
             -Â∏ß
 152   4                      //             break;
 153   4                      //         }
 154   4                      //     }
 155   4                      // }
 156   4      
 157   4                      {
 158   5                          tmr0_disable();
 159   5                          tmr0_cnt = 0;
 160   5                          __IRQnIPnPop(UART0_IRQn);
 161   5                          return;
 162   5                      }
 163   4                  } // if ((cur_recv_len) == frame_len)
 164   3      #endif
 165   3              } // if (0 == recved_flagbuf[blank_index])
 166   2              // else // Â¶ÇÊûúÂΩìÂâçÁºìÂÜ≤Âå∫‰∏≠Ê≤°ÊúâÂâ©‰Ωô‰ΩçÁΩÆÊù•Â≠òÊîæ‰∏Ä‰∏™Â∏ßÔºå
 167   2              // {
C51 COMPILER V9.60.7.0   UART0                                                             11/28/2024 14:06:58 PAGE 4   

 168   2              // }
 169   2      
 170   2          } // if (UART0_STA & UART_RX_DONE(0x1))
 171   1      
 172   1          // ÈÄÄÂá∫‰∏≠Êñ≠ËÆæÁΩÆIPÔºå‰∏çÂèØÂà†Èô§
 173   1          __IRQnIPnPop(UART0_IRQn);
 174   1      }
 175          
 176          // UART0ÂèëÈÄÅ‰∏Ä‰∏™Â≠óËäÇÊï∞ÊçÆÁöÑÂáΩÊï∞
 177          void uart0_sendbyte(u8 senddata)
 178          {
 179   1          while (!(UART0_STA & UART_TX_DONE(0x01)))
 180   1              ;
 181   1          UART0_DATA = senddata;
 182   1          while (!(UART0_STA & UART_TX_DONE(0x01))) // Á≠âÂæÖËøôÊ¨°ÂèëÈÄÅÂÆåÊàê
 183   1              ;
 184   1      }
 185          
 186          // ÈÄöËøáuart0ÂèëÈÄÅËã•Âπ≤Êï∞ÊçÆ
 187          void uart0_send_buff(u8 *buf, u8 len)
 188          {
 189   1          u8 i = 0;
 190   1          for (; i < len; i++)
 191   1          {
 192   2              uart0_sendbyte(buf[i]);
 193   2          }
 194   1      }
 195          
 196          // ÂØπUART0Êé•Êî∂ÁºìÂÜ≤Âå∫ÁöÑÊï∞ÊçÆËøõË°åÈ™åËØÅÔºàË∂ÖÊó∂È™åËØÅ„ÄÅÈïøÂ∫¶È™åËØÅ„ÄÅÊ†°È™åÂíåËÆ°ÁÆóÔºâ
 197          extern void __uart_buff_check(void);
 198          void uart0_scan_handle(void)
 199          {
 200   1          u8 i = 0;                                  // Âæ™ÁéØËÆ°Êï∞ÂÄºÔºàÊ≥®ÊÑèÂæ™ÁéØÊ¨°Êï∞Ë¶ÅÂ§ß‰∫éÁ≠â‰∫éÊï∞Áª
             -ÑËÉΩÂ≠òÊîæÁöÑÊåá‰ª§Êï∞ÁõÆÔºâ
 201   1          volatile u8 checksum = 0;                  // Â≠òÊîæ‰∏¥Êó∂ÁöÑÊ†°È™åÂíå
 202   1          volatile bit __flag_is_crc_or_len_err = 0; // Ê†áÂøó‰ΩçÔºåÊ†°È™åÂíå / Êï∞ÊçÆÈïøÂ∫¶ ÊòØÂê¶ÈîôËØØ,0--Êú™
             -Âá∫ÈîôÔºå1--Âá∫Èîô
 203   1      
 204   1      #if 1 // Êé•Êî∂Ë∂ÖÊó∂Â§ÑÁêÜ
 205   1      
 206   1          if (tmr0_cnt > 10) // ‰∏ÄÂ∏ßÂÜÖÔºåË∂ÖËøá10msÊ≤°ÊúâÊî∂Âà∞Êï∞ÊçÆ
 207   1          {
 208   2              // Â¶ÇÊûúË∂ÖÊó∂
 209   2              // uart0_sendstr("Time out!\n");
 210   2      
 211   2              tmr0_disable(); // ÂÖ≥Èó≠ÂÆöÊó∂Âô®
 212   2              tmr0_cnt = 0;   // Ê∏ÖÁ©∫ÂÆöÊó∂Âô®ËÆ°Êï∞ÂÄº
 213   2      
 214   2              // ÂΩìÂâçÁöÑÊï∞ÊçÆÂ∏ß‰ΩúÂ∫ü
 215   2              cur_recv_len = 0;         // ÂΩìÂâçÊé•Êî∂Âà∞ÁöÑÂ∏ßÁöÑÈïøÂ∫¶Ê∏ÖÈõ∂
 216   2              frame_len = 0;            // Ë¶ÅÊé•Êî∂ÁöÑÂ∏ßÁöÑÈïøÂ∫¶ÔºåÊ∏ÖÈõ∂
 217   2              flag_is_recving_data = 0; // ÈáçÊñ∞ÂºÄÂßãÊé•Êî∂Êï∞ÊçÆ
 218   2      
 219   2              // if (0 == recved_flagbuf[blank_index])
 220   2              // {
 221   2              //     memset(uart0_recv_buf[blank_index], 0, FRAME_MAX_LEN); // Ê∏ÖÁ©∫Ë∂ÖÊó∂ÁöÑÊåá‰ª§ÂØπÂ∫îÁöÑÊé•
             -Êî∂ÁºìÂÜ≤Âå∫
 222   2              // }
 223   2      
 224   2      #if USE_MY_DEBUG
                      printf("recv time out! \n");
              #endif
C51 COMPILER V9.60.7.0   UART0                                                             11/28/2024 14:06:58 PAGE 5   

 227   2      
 228   2      #if 0
                      for (i = 0; i < (UART0_RXBUF_LEN) / (FRAME_MAX_LEN); i++)
                      {
                          printf("%d :\t", i);
                          for (j = 0; j < FRAME_MAX_LEN; j++)
                          {
                              printf("%x ", uart0_recv_buf[i][j]);
                          }
                          printf("\n");
                      }
              #endif // MY_DEBUG
 239   2      
 240   2              return;
 241   2          }
 242   1      #endif // Êé•Êî∂Ë∂ÖÊó∂Â§ÑÁêÜ
 243   1      
 244   1          // ÂØπÊî∂Âà∞ÁöÑÊï∞ÊçÆÂ∏ßËøõË°åÈ™åËØÅ
 245   1          for (i = 0; i < ((UART0_RXBUF_LEN) / (FRAME_MAX_LEN)); i++)
 246   1          {
 247   2              if (recved_flagbuf[i])
 248   2              {
 249   3                  // Â¶ÇÊûúÂØπÂ∫îÁöÑ‰ΩçÁΩÆÊúâÂÆåÊï¥ÁöÑÊï∞ÊçÆÂ∏ß
 250   3                  // __uart_buff_check(); // ÊµãËØïÁî®
 251   3      
 252   3                  if (uart0_recv_len[i] != uart0_recv_buf[i][1])
 253   3                  {
 254   4      // Â¶ÇÊûúÊï∞ÊçÆÂ∏ßÁöÑÈïøÂ∫¶‰∏çÊ≠£Á°Æ
 255   4      #if USE_MY_DEBUG
                              printf("format len invalid!\n");
                              printf("%d  %d \n", (u32)uart0_recv_len[i], (u32)uart0_recv_buf[i][1]);
                              __uart_buff_check(); // ÊâìÂç∞‰∏≤Âè£Êé•Êî∂ÁºìÂÜ≤Âå∫‰∏≠ÁöÑÊï∞ÊçÆ
              #endif
 260   4                      recved_flagbuf[i] = 0;
 261   4                      recv_frame_cnt--;
 262   4                      memset(uart0_recv_buf[i], 0, FRAME_MAX_LEN);
 263   4      
 264   4                      return;
 265   4                  }
 266   3      
 267   3                  {                          // ËÆ°ÁÆóÊ†°È™åÂíå
 268   4                      u8 __loop_crc_cnt = 0; // Áî®‰∫éËÆ°ÁÆóÊ†°È™åÂíåÁöÑÂæ™ÁéØËÆ°Êï∞ÂÄº
 269   4                      checksum = 0;
 270   4                      for (__loop_crc_cnt = 0; __loop_crc_cnt < (uart0_recv_len[i] - 1); __loop_crc_cnt++)
 271   4                      {
 272   5                          checksum += uart0_recv_buf[i][__loop_crc_cnt];
 273   5                      }
 274   4      
 275   4                      // checksum &= 0x0F; // Âèñ‰Ωé4‰Ωç‰Ωú‰∏∫Ê†°È™å
 276   4                      checksum &= 0xFF; // Âèñ8‰Ωç‰Ωú‰∏∫Ê†°È™å
 277   4                      if (checksum != (uart0_recv_buf[i][uart0_recv_len[i] - 1]))
 278   4                      {
 279   5                          // Â¶ÇÊûúËÆ°ÁÆóÁöÑÊ†°È™åÂíå‰∏éÊî∂Âà∞ÁöÑÊ†°È™åÂíå‰∏ç‰∏ÄËá¥
 280   5                          __flag_is_crc_or_len_err = 1;
 281   5                      }
 282   4                  } // ËÆ°ÁÆóÊ†°È™åÂíå
 283   3      
 284   3                  if (__flag_is_crc_or_len_err)
 285   3                  {
 286   4      #if USE_MY_DEBUG
                              printf("recv crc or len err! \n");
              #endif
C51 COMPILER V9.60.7.0   UART0                                                             11/28/2024 14:06:58 PAGE 6   

 289   4                      // flag_is_recving_data = 0;
 290   4                      __flag_is_crc_or_len_err = 0; //
 291   4                      recved_flagbuf[i] = 0;
 292   4                      recv_frame_cnt--;
 293   4                      memset(uart0_recv_buf[i], 0, FRAME_MAX_LEN); // Ê∏ÖÁ©∫Ê†°È™åÂíåÈîôËØØÁöÑÊåá‰ª§ÂØπÂ∫îÁöÑÁºì
             -ÂÜ≤Âå∫
 294   4                  }
 295   3      
 296   3                  // Â¶ÇÊûúËøêË°åÂà∞ËøôÈáåÔºåÊï∞ÊçÆÈÉΩÊ≠£Â∏∏
 297   3                  flagbuf_valid_instruction[i] = 1; // ÂØπÂ∫îÁöÑÊ†áÂøó‰ΩçÁΩÆ‰∏ÄÔºåË°®Á§∫Êî∂Âà∞‰∫ÜÂêàÊ≥ïÁöÑÊåá‰ª§
 298   3              } // if (recved_flagbuf[i])
 299   2          } // for (i = 0; i < ((UART0_RXBUF_LEN) / (FRAME_MAX_LEN)); i++)
 300   1      }
 301          
 302          // Ê∏ÖÈô§‰∏≤Âè£Êé•Êî∂ÁºìÂÜ≤Âå∫‰∏≠ÔºåÂçï‰∏™Â∑≤ÁªèÂ§ÑÁêÜÂ•ΩÁöÑÊåá‰ª§
 303          void uart_clear_single_instruction(u8 index)
 304          {
 305   1          flagbuf_valid_instruction[index] = 0;            // Ê∏ÖÁ©∫ÁºìÂÜ≤Âå∫ÂØπÂ∫îÁöÑÂÖÉÁ¥†ÔºåË°®Á§∫ËØ•‰∏ãÊ†áÁö
             -ÑÊåá‰ª§Â∑≤ÁªèÂ§ÑÁêÜ
 306   1          uart0_recv_len[index] = 0;                       // Ê∏ÖÈô§ÁºìÂÜ≤Âå∫‰∏≠Êåá‰ª§ÂØπÂ∫îÁöÑÈïøÂ∫¶
 307   1          recved_flagbuf[index] = 0;                       // Ê∏ÖÈô§Êé•Êî∂Âà∞Êåá‰ª§ÁöÑÊ†áÂøó‰Ωç
 308   1          memset(uart0_recv_buf[index], 0, FRAME_MAX_LEN); // Ê∏ÖÁ©∫ÁºìÂÜ≤Âå∫ÂØπÂ∫îÁöÑÊåá‰ª§
 309   1      }
 310          
 311          #if 1
 312          // ÊµãËØïÁî®ÁöÑÁ®ãÂ∫èÔºö
 313          // ÊòæÁ§∫‰∏≤Âè£ÁºìÂÜ≤Âå∫‰∏≠ÁöÑÊï∞ÊçÆÔºö
 314          void __uart_buff_check(void)
 315          {
 316   1          u8 i = 0;
 317   1      
 318   1          u8 k = 0;
 319   1          // if (test_bit)
 320   1          // {
 321   1          //     test_bit = 0;
 322   1          for (i = 0; i < (UART0_RXBUF_LEN) / (FRAME_MAX_LEN); i++)
 323   1          {
 324   2              uart0_sendbyte(i + '0');
 325   2              uart0_sendbyte('\n');
 326   2              for (k = 0; k < FRAME_MAX_LEN; k++)
 327   2              {
 328   3                  printf("%2x ", (u16)uart0_recv_buf[i][k]);
 329   3              }
 330   2      
 331   2              printf("\n==========================\n");
 332   2          }
 333   1          // }
 334   1      }
 335          #endif
 336          
 337          #if 0
                          switch (uart0_recv_len[i])
                          {
                          case 4:
              
                              // Â¶ÇÊûúÊòØÂõõ‰∏™Â≠óËäÇÁöÑÊï∞ÊçÆ
                              checksum = (uart0_recv_buf[i][0] + uart0_recv_buf[i][1] + uart0_recv_buf[i][2]) & 0x0F;
              
                              if (checksum != uart0_recv_buf[i][3])
                              {
                                  // Â¶ÇÊûúËÆ°ÁÆóÂæóÂá∫ÁöÑÊ†°È™åÂíå‰∏éÊï∞ÊçÆÂ∏ß‰∏≠ÁöÑÊ†°È™åÂíå‰∏ç‰∏ÄËá¥
                                  // ËØ¥Êòé‰º†ËæìÁöÑÊï∞ÊçÆÊúâËØØ
C51 COMPILER V9.60.7.0   UART0                                                             11/28/2024 14:06:58 PAGE 7   

                                  // uart0_sendstr("checknum err_4Bytes\n");
                                  // recved_flagbuf[i] = 0;
                                  // recv_frame_cnt--;
                                  // memset(uart0_recv_buf[i], 0, FRAME_MAX_LEN);
                                  __flag_is_crc_or_len_err = 1;
                              }
              
                              break;
              
                          case 5:
              
                              // Â¶ÇÊûúÊòØ‰∫î‰∏™Â≠óËäÇÁöÑÊï∞ÊçÆ
                              checksum = (uart0_recv_buf[i][0] + uart0_recv_buf[i][1] + uart0_recv_buf[i][2] + uart0_rec
             -v_buf[i][3]) & 0x0F;
                              if (checksum != uart0_recv_buf[i][4])
                              {
                                  // Â¶ÇÊûúËÆ°ÁÆóÂæóÂá∫ÁöÑÊ†°È™åÂíå‰∏éÊï∞ÊçÆÂ∏ß‰∏≠ÁöÑÊ†°È™åÂíå‰∏ç‰∏ÄËá¥
                                  // ËØ¥Êòé‰º†ËæìÁöÑÊï∞ÊçÆÊúâËØØ
                                  // uart0_sendstr("checknum err_5Bytes\n");
                                  // recved_flagbuf[i] = 0;
                                  // recv_frame_cnt--;
                                  // memset(uart0_recv_buf[i], 0, FRAME_MAX_LEN);
                                  __flag_is_crc_or_len_err = 1;
                              }
              
                              break;
                          case 6:
              
                              // Â¶ÇÊûúÊòØÂÖ≠‰∏™Â≠óËäÇÁöÑÊï∞ÊçÆ
                              checksum = (uart0_recv_buf[i][0] + uart0_recv_buf[i][1] + uart0_recv_buf[i][2] + uart0_rec
             -v_buf[i][3] + uart0_recv_buf[i][4]) & 0x0F;
              
                              if (checksum != uart0_recv_buf[i][5])
                              {
                                  // Â¶ÇÊûúËÆ°ÁÆóÂæóÂá∫ÁöÑÊ†°È™åÂíå‰∏éÊï∞ÊçÆÂ∏ß‰∏≠ÁöÑÊ†°È™åÂíå‰∏ç‰∏ÄËá¥
                                  // ËØ¥Êòé‰º†ËæìÁöÑÊï∞ÊçÆÊúâËØØ
                                  // uart0_sendstr("checknum err_6Bytes\n");
                                  // recved_flagbuf[i] = 0;
                                  // recv_frame_cnt--;
                                  // memset(uart0_recv_buf[i], 0, FRAME_MAX_LEN);
                                  __flag_is_crc_or_len_err = 1;
                              }
              
                              break;
                          case 7: // Â¶ÇÊûúÊòØ7‰∏™Â≠óËäÇÁöÑÊï∞ÊçÆ
                              checksum = (uart0_recv_buf[i][0] + uart0_recv_buf[i][1] + uart0_recv_buf[i][2] + uart0_rec
             -v_buf[i][3] + uart0_recv_buf[i][4] + uart0_recv_buf[i][5]) & 0x0F;
                              if (checksum != uart0_recv_buf[i][6])
                              {
                                  // Â¶ÇÊûúËÆ°ÁÆóÂæóÂá∫ÁöÑÊ†°È™åÂíå‰∏éÊï∞ÊçÆÂ∏ß‰∏≠ÁöÑÊ†°È™åÂíå‰∏ç‰∏ÄËá¥
                                  // ËØ¥Êòé‰º†ËæìÁöÑÊï∞ÊçÆÊúâËØØ
                                  // recved_flagbuf[i] = 0;
                                  // recv_frame_cnt--;
              
                                  __flag_is_crc_or_len_err = 1;
                              }
                              break;
                          case 8: // Â¶ÇÊûúÊòØ8‰∏™Â≠óËäÇÁöÑÊï∞ÊçÆ
                              checksum = (uart0_recv_buf[i][0] + uart0_recv_buf[i][1] + uart0_recv_buf[i][2] + uart0_rec
             -v_buf[i][3] + uart0_recv_buf[i][4] + uart0_recv_buf[i][5] + uart0_recv_buf[i][6]) & 0x0F;
                              if (checksum != uart0_recv_buf[i][7])
                              {
C51 COMPILER V9.60.7.0   UART0                                                             11/28/2024 14:06:58 PAGE 8   

                                  // Â¶ÇÊûúËÆ°ÁÆóÂæóÂá∫ÁöÑÊ†°È™åÂíå‰∏éÊï∞ÊçÆÂ∏ß‰∏≠ÁöÑÊ†°È™åÂíå‰∏ç‰∏ÄËá¥
                                  // ËØ¥Êòé‰º†ËæìÁöÑÊï∞ÊçÆÊúâËØØ
                                  // recved_flagbuf[i] = 0;
                                  // recv_frame_cnt--;
                                  __flag_is_crc_or_len_err = 1;
                              }
                              break;
              
                          default:
                              // Â¶ÇÊûú‰∏çÊòØÂõõ„ÄÅ‰∫î„ÄÅÂÖ≠„ÄÅ‰∏É„ÄÅÂÖ´‰∏™Â≠óËäÇÁöÑÊï∞ÊçÆÔºåËØ¥ÊòéÊé•Êî∂ÊúâËØØÔºåÁõ¥Êé•
             -ÊäõÂºÉËøô‰∏ÄÂ∏ßÊï∞ÊçÆ
              #if USE_MY_DEBUG
                              // printf("recv cnt err\n");
                              __flag_is_crc_or_len_err = 1;
              #endif
                              // recved_flagbuf[i] = 0;
                              // recv_frame_cnt--;
                              // memset(uart0_recv_buf[i], 0, FRAME_MAX_LEN);
              
                              break;
                          } // switch (uart0_recv_len[i])
              #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1045    ----
   CONSTANT SIZE    =     34    ----
   XDATA SIZE       =     46      10
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
