C51 COMPILER V9.60.7.0   UART0                                                             10/26/2024 17:00:25 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE UART0
OBJECT MODULE PLACED IN .\Release\Objects\uart0.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\Hardware\uart0.c LARGE OPTIMIZE(8,SIZE) BROWSE INTVECTOR(0X000C) I
                    -NCDIR(..\..\Libraries\Include;..\..\User;..\..\User\lib;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\L
                    -istings\uart0.lst) OBJECT(.\Release\Objects\uart0.obj)

line level    source

   1          #include "uart0.h"
   2          
   3          #include <string.h> // memset()
   4          
   5          // 设置的波特率需要适配单片机的时钟，这里直接使用了官方的代码
   6          #define USER_UART0_BAUD ((SYSCLK - UART0_BAUDRATE) / (UART0_BAUDRATE))
   7          
   8          // 用来存放接收的数据帧的缓冲区
   9          volatile u8 uart0_recv_buf[(UART0_RXBUF_LEN) / (FRAME_MAX_LEN)][FRAME_MAX_LEN] = {0};
  10          // 用于记录接收缓冲区的对应的数据帧的长度
  11          volatile u8 uart0_recv_len[(UART0_RXBUF_LEN) / (FRAME_MAX_LEN)] = {0};
  12          // 记录缓冲区中对应的位置是否有数据的标志位（数组）
  13          // 例如，缓冲区下标0的位置有指令，标志位数组下标0的元素值为1，没有指令，元素的值为0
  14          volatile u8 recved_flagbuf[(UART0_RXBUF_LEN) / (FRAME_MAX_LEN)] = {0};
  15          
  16          // 串口中断服务函数中，接收一帧的标志位，0--准备接收一帧的第一个字节，1--正在接收该帧的数据
  17          static volatile bit recv_frame_flag = 0;
  18          static volatile u8 frame_len = 0;    // 记录串口中断服务函数中，当前要接收的数据帧的字节数
  19          static volatile u8 cur_recv_len = 0; // 记录串口中断服务函数中，当前已接收的数据帧的字节数
  20          volatile u8 recv_frame_cnt = 0;      // 接收到的数据帧的个数
  21          
  22          static volatile u32 blank_index = 0; // 记录当前存放数据帧的缓冲区的空的地方(缓冲区下标)，准备存放一帧的数
             -据
  23          
  24          // 重写putchar()函数
  25          char putchar(char c)
  26          {
  27   1          uart0_sendbyte(c);
  28   1          return c;
  29   1      }
  30          
  31          #ifdef DEVELOPMENT_BOARD
              // uart0初始化
              // 波特率由宏 UART0_BAUDRATE 来决定
              void uart0_init(void)
              {
                  // 开发板上，P11为发送引脚，P12为接收引脚
                  P1_MD0 &= (~GPIO_P11_MODE_SEL(0x3) | ~GPIO_P12_MODE_SEL(0x3));
                  P1_MD0 |= GPIO_P11_MODE_SEL(0x1); // 输出模式
                  FOUT_S11 |= GPIO_FOUT_UART0_TX;   // 配置P11为UART0_TX
                  FIN_S7 |= GPIO_FIN_SEL_P12;       // 配置P12为UART0_RX
              
                  __EnableIRQ(UART0_IRQn); // 打开UART模块中断
                  IE_EA = 1;               // 打开总中断
              
                  UART0_BAUD1 = (USER_UART0_BAUD >> 8) & 0xFF; // 配置波特率高八位
                  UART0_BAUD0 = USER_UART0_BAUD & 0xFF;        // 配置波特率低八位
                  UART0_CON0 = UART_STOP_BIT(0x0) |
                               UART_RX_IRQ_EN(0x1) |
                               UART_EN(0x1); // 8bit数据，1bit停止位，使能RX中断
              }
              #endif // DEVELOPMENT_BOARD
  52          
C51 COMPILER V9.60.7.0   UART0                                                             10/26/2024 17:00:25 PAGE 2   

  53          #ifdef CIRCUIT_BOARD
  54          // uart0初始化
  55          // 波特率由宏 UART0_BAUDRATE 来决定
  56          void uart0_init(void)
  57          {
  58   1          // 电路板上，P11为发送引脚，P12为接收引脚
  59   1          P1_MD0 &= (~GPIO_P11_MODE_SEL(0x3) | ~GPIO_P12_MODE_SEL(0x3));
  60   1          P1_MD0 |= GPIO_P11_MODE_SEL(0x1); // 输出模式
  61   1          FOUT_S11 |= GPIO_FOUT_UART0_TX;   // 配置P11为UART0_TX
  62   1          FIN_S7 |= GPIO_FIN_SEL_P12;       // 配置P12为UART0_RX
  63   1      
  64   1          __EnableIRQ(UART0_IRQn); // 打开UART模块中断
  65   1          IE_EA = 1;               // 打开总中断
  66   1      
  67   1          UART0_BAUD1 = (USER_UART0_BAUD >> 8) & 0xFF; // 配置波特率高八位
  68   1          UART0_BAUD0 = USER_UART0_BAUD & 0xFF;        // 配置波特率低八位
  69   1          UART0_CON0 = UART_STOP_BIT(0x0) |
  70   1                       UART_RX_IRQ_EN(0x1) |
  71   1                       UART_EN(0x1); // 8bit数据，1bit停止位，使能RX中断
  72   1      
  73   1          // memset(uart0_recv_buf, 0, sizeof(uart0_recv_buf));
  74   1      }
  75          #endif // DEVELOPMENT_BOARD
  76          
  77          // UART0中断服务函数（接收中断）
  78          void UART0_IRQHandler(void) interrupt UART0_IRQn
  79          {
  80   1          // 进入中断设置IP，不可删除
  81   1          __IRQnIPnPush(UART0_IRQn);
  82   1          // ---------------- 用户函数处理 -------------------
  83   1          // RX接收完成中断
  84   1          if (UART0_STA & UART_RX_DONE(0x1))
  85   1          {
  86   2              if (0 == recv_frame_flag && UART0_DATA == 0xA5)
  87   2              {
  88   3                  // 如果是新的一帧数据（以格式头0xA5开始），打开定时器，为超时判断做准备
  89   3                  recv_frame_flag = 1;
  90   3      
  91   3                  {
  92   4                      // 重新给TMR0配置时钟
  93   4                      TMR0_CONL &= ~(TMR_SOURCE_SEL(0x07)); // 清除定时器的时钟源配置寄存器
  94   4                      TMR0_CONL |= TMR_SOURCE_SEL(0x06);    // 配置定时器的时钟源，使用系统时钟（约21MHz）
  95   4                      __EnableIRQ(TMR0_IRQn);               // 使能中断
  96   4                      IE_EA = 1;                            // 打开总中断
  97   4                  }
  98   3              }
  99   2              else if (0 == recv_frame_flag && UART0_DATA != 0xA5)
 100   2              {
 101   3                  // 如果是新的一帧数据，却不是以0xA5开头，说明这一帧数据无效
 102   3      
 103   3                  // 退出中断设置IP，不可删除
 104   3                  __IRQnIPnPop(UART0_IRQn);
 105   3                  return;
 106   3              }
 107   2              else if (1 == recv_frame_flag && UART0_DATA == 0xA5)
 108   2              {
 109   3                  // 如果正在接收一帧数据，却又收到了一次格式头，舍弃之前收到的数据，重新接收这一帧
 110   3                  cur_recv_len = 0;
 111   3                  frame_len = 0;
 112   3              }
 113   2              else if (recv_frame_cnt > ((UART0_RXBUF_LEN) / (FRAME_MAX_LEN)))
 114   2              {
C51 COMPILER V9.60.7.0   UART0                                                             10/26/2024 17:00:25 PAGE 3   

 115   3                  // 如果缓冲区已满，存不下更多的数据帧
 116   3      
 117   3                  // 退出中断设置IP，不可删除
 118   3                  __IRQnIPnPop(UART0_IRQn);
 119   3                  return;
 120   3              }
 121   2      
 122   2              if (1 == cur_recv_len)
 123   2              {
 124   3                  // 如果接收到一帧的第二个字节的数据，记录下要接收的数据长度
 125   3                  frame_len = UART0_DATA;
 126   3              }
 127   2      
 128   2              if (0 == recved_flagbuf[blank_index])
 129   2              {
 130   3                  // 如果缓冲区中有剩余位置来存放一个帧，才放入数据
 131   3                  uart0_recv_buf[blank_index][cur_recv_len++] = UART0_DATA;
 132   3                  uart0_recv_len[blank_index] = cur_recv_len; // 更新当前数据帧的长度
 133   3                  tmr0_cnt = 0;                               // 每接收到一个字节数据，清空超时的计时
 134   3              }
 135   2      
 136   2              // 如果发送方填错了数据帧的长度，这里的判断就会影响下一帧数据的接收
 137   2              // 因此在中断开头加了格式头的识别，在扫描函数加了帧长度的验证，避免数据过长或过短的情况
 138   2              if (cur_recv_len == frame_len)
 139   2              {
 140   3                  // 如果接收完了一帧数据
 141   3                  recv_frame_flag = 0; // 标志位清零，准备接收下一帧数据
 142   3                  cur_recv_len = 0;
 143   3                  frame_len = 0;
 144   3      
 145   3                  recved_flagbuf[blank_index] = 1; // 对应的接收完成标志位置一
 146   3                  recv_frame_cnt++;                // 接收到完整的一帧，计数值加一
 147   3      
 148   3                  if (recv_frame_cnt < ((UART0_RXBUF_LEN) / (FRAME_MAX_LEN)))
 149   3                  {
 150   4                      // 如果数组中有空位（接收的数据帧个数 < 缓冲区总共能接收的数据帧个数）
 151   4      
 152   4                      // 偏移到数组中空的地方，准备填入下一个数据帧
 153   4                      while (1)
 154   4                      {
 155   5                          blank_index++;
 156   5      
 157   5                          if (blank_index >= ((UART0_RXBUF_LEN) / (FRAME_MAX_LEN)))
 158   5                          {
 159   6                              // 如果下标超出了缓冲区能容纳的指令个数
 160   6                              blank_index = 0;
 161   6                          }
 162   5      
 163   5                          if (0 == recved_flagbuf[blank_index])
 164   5                          {
 165   6                              // 如果是空的一处缓冲区，退出，准备给下一次接收数据帧
 166   6                              break;
 167   6                          }
 168   5                      }
 169   4                  }
 170   3      
 171   3                  {
 172   4                      // 不给定时器提供时钟，让它停止计数
 173   4                      TMR0_CONL &= ~(TMR_SOURCE_SEL(0x07)); // 清除定时器的时钟源配置寄存器
 174   4                      TMR0_CONL |= TMR_SOURCE_SEL(0x05);    // 配置定时器的时钟源，不用任何时钟
 175   4                      // 清除定时器的计数值
 176   4                      TMR0_CNTL = 0;
C51 COMPILER V9.60.7.0   UART0                                                             10/26/2024 17:00:25 PAGE 4   

 177   4                      TMR0_CNTH = 0;
 178   4                      __DisableIRQ(TMR0_IRQn); // 关闭中断（不使能中断）
 179   4                      tmr0_cnt = 0;
 180   4                  }
 181   3              }
 182   2          }
 183   1      
 184   1          // 退出中断设置IP，不可删除
 185   1          __IRQnIPnPop(UART0_IRQn);
 186   1      }
 187          
 188          // UART0发送一个字节数据的函数
 189          void uart0_sendbyte(u8 senddata)
 190          {
 191   1          while (!(UART0_STA & UART_TX_DONE(0x01)))
 192   1              ;
 193   1          UART0_DATA = senddata;
 194   1          while (!(UART0_STA & UART_TX_DONE(0x01))) // 等待这次发送完成
 195   1              ;
 196   1      }
 197          
 198          // 对UART0接收缓冲区的数据进行验证（超时验证、长度验证、校验和计算）
 199          void uart0_scan_handle(void)
 200          {
 201   1          u16 i = 0; // 循环计数值
 202   1      
 203   1          u32 checksum = 0; // 存放临时的校验和
 204   1      
 205   1          // u16 j = 0; // 测试用的循环计数值
 206   1      
 207   1      #if 0  // 测试用
                  static volatile u8 tmp1 = 0;
                  static volatile u8 tmp2 = 0;
              
                  tmp2 = recv_frame_cnt;
              
                  if (tmp1 != tmp2) // 如果接收的帧的个数不一样
                  {
                      for (i = 0; i < (UART0_RXBUF_LEN) / (FRAME_MAX_LEN); i++)
                      {
                          printf("%d :\t", i);
                          for (j = 0; j < FRAME_MAX_LEN; j++)
                          {
                              printf("%x ", (int16)uart0_recv_buf[i][j]);
                          }
                          printf("\n");
                      }
                  }
              #endif // 测试用
 226   1      
 227   1      #if 1 // 接收超时处理
 228   1      
 229   1          if (tmr0_cnt > 100) // 一帧内，超过10ms没有收到数据
 230   1          {
 231   2              // 如果超时
 232   2              // uart0_sendstr("Time out!\n");
 233   2      
 234   2              tmr0_disable(); // 关闭定时器
 235   2              tmr0_cnt = 0;   // 清空定时器计数值
 236   2      
 237   2              // 当前的数据帧作废
 238   2              cur_recv_len = 0;    // 当前接收到的帧的长度清零
C51 COMPILER V9.60.7.0   UART0                                                             10/26/2024 17:00:25 PAGE 5   

 239   2              frame_len = 0;       // 要接收的帧的长度，清零
 240   2              recv_frame_flag = 0; // 重新开始接收数据
 241   2      
 242   2      #if 0  // 向串口发送整个缓冲区的数据
                      for (i = 0; i < (UART0_RXBUF_LEN) / (FRAME_MAX_LEN); i++)
                      {
                          uart0_sendbyte(i + '0');
                          uart0_sendbyte('\n');
                          uart0_sendnums(uart0_recv_buf[i], FRAME_MAX_LEN);
                          uart0_sendstr("\n==========================\n");
                      }
              #endif // 向串口发送整个缓冲区的数据
 251   2      
 252   2      #if 0
                      for (i = 0; i < (UART0_RXBUF_LEN) / (FRAME_MAX_LEN); i++)
                      {
                          printf("%d :\t", i);
                          for (j = 0; j < FRAME_MAX_LEN; j++)
                          {
                              printf("%x ", uart0_recv_buf[i][j]);
                          }
                          printf("\n");
                      }
              #endif // MY_DEBUG
 263   2      
 264   2              return;
 265   2          }
 266   1      #endif // 接收超时处理
 267   1      
 268   1          // 对收到的数据帧进行验证
 269   1          for (i = 0; i < ((UART0_RXBUF_LEN) / (FRAME_MAX_LEN)); i++)
 270   1          {
 271   2              if (recved_flagbuf[i])
 272   2              {
 273   3                  // 如果对应的位置有完整的数据帧
 274   3      
 275   3                  if (uart0_recv_len[i] != uart0_recv_buf[i][1])
 276   3                  {
 277   4                      // 如果数据帧的长度不正确
 278   4                      // uart0_sendstr("format len invalid!\n");
 279   4                      recved_flagbuf[i] = 0;
 280   4                      recv_frame_cnt--;
 281   4                      // memset(uart0_recv_buf[i], 0, FRAME_MAX_LEN);
 282   4      
 283   4                      // for (i = 0; i < (UART0_RXBUF_LEN) / (FRAME_MAX_LEN); i++)
 284   4                      // {
 285   4                      //     uart0_sendbyte(i + '0');
 286   4                      //     uart0_sendbyte('\n');
 287   4                      //     uart0_sendnums(uart0_recv_buf[i], FRAME_MAX_LEN);
 288   4                      //     uart0_sendstr("\n==========================\n");
 289   4                      // }
 290   4      
 291   4                      return;
 292   4                  }
 293   3      
 294   3                  switch (uart0_recv_len[i])
 295   3                  {
 296   4                  case 4:
 297   4      
 298   4                      // 如果是四个字节的数据
 299   4                      checksum = (uart0_recv_buf[i][0] + uart0_recv_buf[i][1] + uart0_recv_buf[i][2]) & 0x0F;
 300   4      
C51 COMPILER V9.60.7.0   UART0                                                             10/26/2024 17:00:25 PAGE 6   

 301   4                      if (checksum != uart0_recv_buf[i][3])
 302   4                      {
 303   5                          // 如果计算得出的校验和与数据帧中的校验和不一致
 304   5                          // 说明传输的数据有误
 305   5                          // uart0_sendstr("checknum err_4Bytes\n");
 306   5                          recved_flagbuf[i] = 0;
 307   5                          recv_frame_cnt--;
 308   5                          // memset(uart0_recv_buf[i], 0, FRAME_MAX_LEN);
 309   5                      }
 310   4      
 311   4                      break;
 312   4      
 313   4                  case 5:
 314   4      
 315   4                      // 如果是五个字节的数据
 316   4                      checksum = (uart0_recv_buf[i][0] + uart0_recv_buf[i][1] + uart0_recv_buf[i][2] + uart0_rec
             -v_buf[i][3]) & 0x0F;
 317   4      
 318   4                      if (checksum != uart0_recv_buf[i][4])
 319   4                      {
 320   5                          // 如果计算得出的校验和与数据帧中的校验和不一致
 321   5                          // 说明传输的数据有误
 322   5                          // uart0_sendstr("checknum err_5Bytes\n");
 323   5                          recved_flagbuf[i] = 0;
 324   5                          recv_frame_cnt--;
 325   5                          // memset(uart0_recv_buf[i], 0, FRAME_MAX_LEN);
 326   5                      }
 327   4      
 328   4                      break;
 329   4                  case 6:
 330   4      
 331   4                      // 如果是六个字节的数据
 332   4                      checksum = (uart0_recv_buf[i][0] + uart0_recv_buf[i][1] + uart0_recv_buf[i][2] + uart0_rec
             -v_buf[i][3] + uart0_recv_buf[i][4]) & 0x0F;
 333   4      
 334   4                      if (checksum != uart0_recv_buf[i][5])
 335   4                      {
 336   5                          // 如果计算得出的校验和与数据帧中的校验和不一致
 337   5                          // 说明传输的数据有误
 338   5                          // uart0_sendstr("checknum err_6Bytes\n");
 339   5                          recved_flagbuf[i] = 0;
 340   5                          recv_frame_cnt--;
 341   5                          // memset(uart0_recv_buf[i], 0, FRAME_MAX_LEN);
 342   5                      }
 343   4      
 344   4                      break;
 345   4      
 346   4                  default:
 347   4                      // 如果不是四、五或者六个字节的数据，说明接收有误，直接抛弃这一帧数据
 348   4                      // uart0_sendstr("recv cnt err\n");
 349   4                      recved_flagbuf[i] = 0;
 350   4                      recv_frame_cnt--;
 351   4                      // memset(uart0_recv_buf[i], 0, FRAME_MAX_LEN);
 352   4      
 353   4                      break;
 354   4                  }
 355   3      
 356   3                  // 如果运行到这里，数据都正常
 357   3              }
 358   2          }
 359   1      }

C51 COMPILER V9.60.7.0   UART0                                                             10/26/2024 17:00:25 PAGE 7   


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1228    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     43       7
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
