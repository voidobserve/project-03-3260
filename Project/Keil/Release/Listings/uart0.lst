C51 COMPILER V9.60.7.0   UART0                                                             10/28/2024 17:51:21 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE UART0
OBJECT MODULE PLACED IN .\Release\Objects\uart0.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\Hardware\uart0.c LARGE OPTIMIZE(8,SIZE) BROWSE INTVECTOR(0X000C) I
                    -NCDIR(..\..\Libraries\Include;..\..\User;..\..\User\lib;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\L
                    -istings\uart0.lst) OBJECT(.\Release\Objects\uart0.obj)

line level    source

   1          #include "uart0.h"
   2          
   3          #include <string.h> // memset()
   4          
   5          // ÉèÖÃµÄ²¨ÌØÂÊÐèÒªÊÊÅäµ¥Æ¬»úµÄÊ±ÖÓ£¬ÕâÀïÖ±½ÓÊ¹ÓÃÁË¹Ù·½µÄ´úÂë
   6          #define USER_UART0_BAUD ((SYSCLK - UART0_BAUDRATE) / (UART0_BAUDRATE))
   7          
   8          // ÓÃÀ´´æ·Å½ÓÊÕµÄÊý¾ÝÖ¡µÄ»º³åÇø
   9          volatile u8 uart0_recv_buf[(UART0_RXBUF_LEN) / (FRAME_MAX_LEN)][FRAME_MAX_LEN] = {0};
  10          // ÓÃÓÚ¼ÇÂ¼½ÓÊÕ»º³åÇøµÄ¶ÔÓ¦µÄÊý¾ÝÖ¡µÄ³¤¶È
  11          volatile u8 uart0_recv_len[(UART0_RXBUF_LEN) / (FRAME_MAX_LEN)] = {0};
  12          // ¼ÇÂ¼»º³åÇøÖÐ¶ÔÓ¦µÄÎ»ÖÃÊÇ·ñÓÐÊý¾ÝµÄ±êÖ¾Î»£¨Êý×é£©
  13          // ÀýÈç£¬»º³åÇøÏÂ±ê0µÄÎ»ÖÃÓÐÖ¸Áî£¬±êÖ¾Î»Êý×éÏÂ±ê0µÄÔªËØÖµÎª1£¬Ã»ÓÐÖ¸Áî£¬ÔªËØµÄÖµÎª0
  14          volatile u8 recved_flagbuf[(UART0_RXBUF_LEN) / (FRAME_MAX_LEN)] = {0};
  15          
  16          volatile u8 flagbuf_valid_instruction[(UART0_RXBUF_LEN) / (FRAME_MAX_LEN)] = {0}; // ´æ·ÅÓÐºÏ·¨Ö¸ÁîµÄ±êÖ¾Î
             -»Êý×é
  17          
  18          // ´®¿ÚÖÐ¶Ï·þÎñº¯ÊýÖÐ£¬½ÓÊÕÒ»Ö¡µÄ±êÖ¾Î»£¬0--×¼±¸½ÓÊÕÒ»Ö¡µÄµÚÒ»¸ö×Ö½Ú£¬1--ÕýÔÚ½ÓÊÕ¸ÃÖ¡µÄÊý¾Ý
  19          // static volatile bit recv_frame_flag = 0;
  20          // ´®¿ÚÖÐ¶Ï·þÎñº¯ÊýÖÐ£¬½ÓÊÕÒ»Ö¡µÄ±êÖ¾Î»£¬0--×¼±¸½ÓÊÕÒ»Ö¡µÄµÚÒ»¸ö×Ö½Ú£¬1--ÕýÔÚ½ÓÊÕ¸ÃÖ¡µÄÊý¾Ý
  21          static bit flag_is_recving_data = 0;
  22          static volatile u8 frame_len = 0;    // ¼ÇÂ¼´®¿ÚÖÐ¶Ï·þÎñº¯ÊýÖÐ£¬µ±Ç°Òª½ÓÊÕµÄÊý¾ÝÖ¡µÄ×Ö½ÚÊý
  23          static volatile u8 cur_recv_len = 0; // ¼ÇÂ¼´®¿ÚÖÐ¶Ï·þÎñº¯ÊýÖÐ£¬µ±Ç°ÒÑ½ÓÊÕµÄÊý¾ÝÖ¡µÄ×Ö½ÚÊý
  24          volatile u8 recv_frame_cnt = 0;      // ½ÓÊÕµ½µÄÊý¾ÝÖ¡µÄ¸öÊý
  25          
  26          static volatile u32 blank_index = 0; // ¼ÇÂ¼µ±Ç°´æ·ÅÊý¾ÝÖ¡µÄ»º³åÇøµÄ¿ÕµÄµØ·½(»º³åÇøÏÂ±ê)£¬×¼±¸´æ·ÅÒ»Ö¡µÄÊý
             -¾Ý
  27          
  28          bit test_bit = 0;
  29          
  30          // ÖØÐ´putchar()º¯Êý
  31          char putchar(char c)
  32          {
  33   1          uart0_sendbyte(c);
  34   1          return c;
  35   1      }
  36          
  37          #ifdef DEVELOPMENT_BOARD
              // uart0³õÊ¼»¯
              // ²¨ÌØÂÊÓÉºê UART0_BAUDRATE À´¾ö¶¨
              void uart0_init(void)
              {
                  // ¿ª·¢°åÉÏ£¬P11Îª·¢ËÍÒý½Å£¬P12Îª½ÓÊÕÒý½Å
                  P1_MD0 &= (~GPIO_P11_MODE_SEL(0x3) | ~GPIO_P12_MODE_SEL(0x3));
                  P1_MD0 |= GPIO_P11_MODE_SEL(0x1); // Êä³öÄ£Ê½
                  FOUT_S11 |= GPIO_FOUT_UART0_TX;   // ÅäÖÃP11ÎªUART0_TX
                  FIN_S7 |= GPIO_FIN_SEL_P12;       // ÅäÖÃP12ÎªUART0_RX
              
                  __EnableIRQ(UART0_IRQn); // ´ò¿ªUARTÄ£¿éÖÐ¶Ï
                  IE_EA = 1;               // ´ò¿ª×ÜÖÐ¶Ï
              
                  UART0_BAUD1 = (USER_UART0_BAUD >> 8) & 0xFF; // ÅäÖÃ²¨ÌØÂÊ¸ß°ËÎ»
C51 COMPILER V9.60.7.0   UART0                                                             10/28/2024 17:51:21 PAGE 2   

                  UART0_BAUD0 = USER_UART0_BAUD & 0xFF;        // ÅäÖÃ²¨ÌØÂÊµÍ°ËÎ»
                  UART0_CON0 = UART_STOP_BIT(0x0) |
                               UART_RX_IRQ_EN(0x1) |
                               UART_EN(0x1); // 8bitÊý¾Ý£¬1bitÍ£Ö¹Î»£¬Ê¹ÄÜRXÖÐ¶Ï
              }
              #endif // DEVELOPMENT_BOARD
  58          
  59          #ifdef CIRCUIT_BOARD
  60          // uart0³õÊ¼»¯
  61          // ²¨ÌØÂÊÓÉºê UART0_BAUDRATE À´¾ö¶¨
  62          void uart0_init(void)
  63          {
  64   1          // µçÂ·°åÉÏ£¬P11Îª·¢ËÍÒý½Å£¬P12Îª½ÓÊÕÒý½Å
  65   1          P1_MD0 &= (~GPIO_P11_MODE_SEL(0x3) | ~GPIO_P12_MODE_SEL(0x3));
  66   1          P1_MD0 |= GPIO_P11_MODE_SEL(0x1); // Êä³öÄ£Ê½
  67   1          FOUT_S11 |= GPIO_FOUT_UART0_TX;   // ÅäÖÃP11ÎªUART0_TX
  68   1          FIN_S7 |= GPIO_FIN_SEL_P12;       // ÅäÖÃP12ÎªUART0_RX
  69   1      
  70   1          __EnableIRQ(UART0_IRQn); // ´ò¿ªUARTÄ£¿éÖÐ¶Ï
  71   1          IE_EA = 1;               // ´ò¿ª×ÜÖÐ¶Ï
  72   1      
  73   1          UART0_BAUD1 = (USER_UART0_BAUD >> 8) & 0xFF; // ÅäÖÃ²¨ÌØÂÊ¸ß°ËÎ»
  74   1          UART0_BAUD0 = USER_UART0_BAUD & 0xFF;        // ÅäÖÃ²¨ÌØÂÊµÍ°ËÎ»
  75   1          UART0_CON0 = UART_STOP_BIT(0x0) |
  76   1                       UART_RX_IRQ_EN(0x1) |
  77   1                       UART_EN(0x1); // 8bitÊý¾Ý£¬1bitÍ£Ö¹Î»£¬Ê¹ÄÜRXÖÐ¶Ï
  78   1      
  79   1          // memset(uart0_recv_buf, 0, sizeof(uart0_recv_buf));
  80   1      }
  81          #endif // DEVELOPMENT_BOARD
  82          
  83          // UART0ÖÐ¶Ï·þÎñº¯Êý£¨½ÓÊÕÖÐ¶Ï£©
  84          void UART0_IRQHandler(void) interrupt UART0_IRQn
  85          {
  86   1          volatile u8 uart0_tmp_val = 0;
  87   1      
  88   1          // ½øÈëÖÐ¶ÏÉèÖÃIP£¬²»¿ÉÉ¾³ý
  89   1          __IRQnIPnPush(UART0_IRQn);
  90   1          // ---------------- ÓÃ»§º¯Êý´¦Àí -------------------
  91   1          // RX½ÓÊÕÍê³ÉÖÐ¶Ï
  92   1          if (UART0_STA & UART_RX_DONE(0x1))
  93   1          {
  94   2              // test_bit = 1;
  95   2              uart0_tmp_val = UART0_DATA;
  96   2      
  97   2              // if ((0 == flag_is_recving_data && UART0_DATA == 0xA5) ||
  98   2              //     (1 == flag_is_recving_data && UART0_DATA == 0xA5))
  99   2              if (uart0_tmp_val == 0xA5)
 100   2              {
 101   3                  // 1. Èç¹ûÊÇÐÂµÄÒ»Ö¡Êý¾Ý£¨ÒÔ¸ñÊ½Í·0xA5¿ªÊ¼£©£¬´ò¿ª¶¨Ê±Æ÷£¬Îª³¬Ê±ÅÐ¶Ï×ö×¼±¸
 102   3                  // 2. Èç¹ûÕýÔÚ½ÓÊÕÒ»Ö¡Êý¾Ý£¬È´ÓÖÊÕµ½ÁËÒ»´Î¸ñÊ½Í·£¬ÉáÆúÖ®Ç°ÊÕµ½µÄÊý¾Ý£¬ÖØÐÂ½ÓÊÕÕâÒ»Ö¡
 103   3                  flag_is_recving_data = 1;
 104   3                  cur_recv_len = 0;
 105   3                  frame_len = 0;
 106   3                  tmr0_disable();
 107   3                  tmr0_cnt = 0;
 108   3                  tmr0_enable();
 109   3              }
 110   2              else if ((0 == flag_is_recving_data && uart0_tmp_val != 0xA5) ||
 111   2                       (recv_frame_cnt >= ((UART0_RXBUF_LEN) / (FRAME_MAX_LEN))))
 112   2              {
 113   3                  // 1. Èç¹ûÊÇÐÂµÄÒ»Ö¡Êý¾Ý£¬È´²»ÊÇÒÔ0xA5¿ªÍ·£¬ËµÃ÷ÕâÒ»Ö¡Êý¾ÝÎÞÐ§
C51 COMPILER V9.60.7.0   UART0                                                             10/28/2024 17:51:21 PAGE 3   

 114   3                  // 2. Èç¹û»º³åÇøÒÑÂú£¬´æ²»ÏÂ¸ü¶àµÄÊý¾ÝÖ¡
 115   3                  // Ö±½ÓÍË³öÖÐ¶Ï£¬²»´¦ÀíÊý¾Ý
 116   3                  tmr0_disable();
 117   3                  tmr0_cnt = 0;
 118   3                  __IRQnIPnPop(UART0_IRQn);
 119   3                  return;
 120   3              }
 121   2      
 122   2              if (1 == cur_recv_len)
 123   2              {
 124   3                  // Èç¹û½ÓÊÕµ½Ò»Ö¡µÄµÚ¶þ¸ö×Ö½ÚµÄÊý¾Ý£¬¼ÇÂ¼ÏÂÒª½ÓÊÕµÄÊý¾Ý³¤¶È
 125   3                  frame_len = uart0_tmp_val;
 126   3              }
 127   2      
 128   2              // ³ÌÐòÔËÐÐµ½ÕâÀï£¬ËµÃ÷ÕýÔÚ½ÓÊÕÒ»¸öÊý¾ÝÖ¡
 129   2              if (0 == recved_flagbuf[blank_index])
 130   2              {
 131   3                  // Èç¹û»º³åÇøÖÐÓÐÊ£ÓàÎ»ÖÃÀ´´æ·ÅÒ»¸öÖ¡£¬²Å·ÅÈëÊý¾Ý
 132   3                  uart0_recv_buf[blank_index][cur_recv_len++] = uart0_tmp_val;
 133   3                  // uart0_recv_buf[0][cur_recv_len++] = UART0_DATA; // ²âÊÔÓÃ
 134   3                  tmr0_cnt = 0; // Ã¿½ÓÊÕµ½Ò»¸ö×Ö½ÚÊý¾Ý£¬Çå¿Õ³¬Ê±µÄ¼ÆÊ±
 135   3      
 136   3      #if 1
 137   3                  if ((cur_recv_len) == frame_len)
 138   3                  {
 139   4                      // Èç¹û½ÓÊÕÍêÁËÒ»Ö¡Êý¾Ý
 140   4                      uart0_recv_len[blank_index] = frame_len; // ¸üÐÂµ±Ç°Êý¾ÝÖ¡µÄ³¤¶È
 141   4                      flag_is_recving_data = 0;                // ±êÖ¾Î»ÇåÁã£¬×¼±¸½ÓÊÕÏÂÒ»Ö¡Êý¾Ý
 142   4                      cur_recv_len = 0;
 143   4                      frame_len = 0;
 144   4      
 145   4                      recved_flagbuf[blank_index] = 1; // ¶ÔÓ¦µÄ½ÓÊÕÍê³É±êÖ¾Î»ÖÃÒ»
 146   4                      recv_frame_cnt++;                // ½ÓÊÕµ½ÍêÕûµÄÒ»Ö¡£¬¼ÆÊýÖµ¼ÓÒ»
 147   4                      test_bit = 1;
 148   4                      blank_index++;
 149   4                      if (blank_index >= ((UART0_RXBUF_LEN) / (FRAME_MAX_LEN)))
 150   4                      {
 151   5                          blank_index = 0;
 152   5                      }
 153   4      
 154   4                      // if (recv_frame_cnt < ((UART0_RXBUF_LEN) / (FRAME_MAX_LEN)))
 155   4                      // {
 156   4                      //     // Èç¹ûÊý×éÖÐÓÐ¿ÕÎ»£¨½ÓÊÕµÄÊý¾ÝÖ¡¸öÊý < »º³åÇø×Ü¹²ÄÜ½ÓÊÕµÄÊý¾ÝÖ¡¸öÊý£©
 157   4      
 158   4                      //     // Æ«ÒÆµ½Êý×éÖÐ¿ÕµÄµØ·½£¬×¼±¸ÌîÈëÏÂÒ»¸öÊý¾ÝÖ¡
 159   4                      //     while (1)
 160   4                      //     {
 161   4                      //         blank_index++;
 162   4      
 163   4                      //         if (blank_index >= ((UART0_RXBUF_LEN) / (FRAME_MAX_LEN)))
 164   4                      //         {
 165   4                      //             // Èç¹ûÏÂ±ê³¬³öÁË»º³åÇøÄÜÈÝÄÉµÄÖ¸Áî¸öÊý
 166   4                      //             blank_index = 0;
 167   4                      //         }
 168   4      
 169   4                      //         if (0 == recved_flagbuf[blank_index])
 170   4                      //         {
 171   4                      //             // Èç¹ûÊÇ¿ÕµÄÒ»´¦»º³åÇø£¬ÍË³ö£¬×¼±¸¸øÏÂÒ»´Î½ÓÊÕÊý¾ÝÖ¡
 172   4                      //             break;
 173   4                      //         }
 174   4                      //     }
 175   4                      // }
C51 COMPILER V9.60.7.0   UART0                                                             10/28/2024 17:51:21 PAGE 4   

 176   4      
 177   4                      {
 178   5                          tmr0_disable();
 179   5                          tmr0_cnt = 0;
 180   5                          __IRQnIPnPop(UART0_IRQn);
 181   5                          return;
 182   5                      }
 183   4                  } // if ((cur_recv_len) == frame_len)
 184   3      #endif
 185   3              } // if (0 == recved_flagbuf[blank_index])
 186   2              // else // Èç¹ûµ±Ç°»º³åÇøÖÐÃ»ÓÐÊ£ÓàÎ»ÖÃÀ´´æ·ÅÒ»¸öÖ¡£¬
 187   2              // {
 188   2              // }
 189   2      
 190   2          } // if (UART0_STA & UART_RX_DONE(0x1))
 191   1      
 192   1          // ÍË³öÖÐ¶ÏÉèÖÃIP£¬²»¿ÉÉ¾³ý
 193   1          __IRQnIPnPop(UART0_IRQn);
 194   1      }
 195          
 196          // UART0·¢ËÍÒ»¸ö×Ö½ÚÊý¾ÝµÄº¯Êý
 197          void uart0_sendbyte(u8 senddata)
 198          {
 199   1          while (!(UART0_STA & UART_TX_DONE(0x01)))
 200   1              ;
 201   1          UART0_DATA = senddata;
 202   1          while (!(UART0_STA & UART_TX_DONE(0x01))) // µÈ´ýÕâ´Î·¢ËÍÍê³É
 203   1              ;
 204   1      }
 205          
 206          // ¶ÔUART0½ÓÊÕ»º³åÇøµÄÊý¾Ý½øÐÐÑéÖ¤£¨³¬Ê±ÑéÖ¤¡¢³¤¶ÈÑéÖ¤¡¢Ð£ÑéºÍ¼ÆËã£©
 207          void uart0_scan_handle(void)
 208          {
 209   1          u8 i = 0;                         // Ñ­»·¼ÆÊýÖµ£¨×¢ÒâÑ­»·´ÎÊýÒª´óÓÚµÈÓÚÊý×éÄÜ´æ·ÅµÄÖ¸ÁîÊýÄ¿£©
 210   1          volatile u8 checksum = 0;         // ´æ·ÅÁÙÊ±µÄÐ£ÑéºÍ
 211   1          volatile bit __flag_is_crc_or_len_err = 0; // ±êÖ¾Î»£¬Ð£ÑéºÍ / Êý¾Ý³¤¶È ÊÇ·ñ´íÎó,0--Î´³ö´í£¬1--³ö´í
 212   1      
 213   1      #if 1 // ½ÓÊÕ³¬Ê±´¦Àí
 214   1      
 215   1          if (tmr0_cnt > 10) // Ò»Ö¡ÄÚ£¬³¬¹ý10msÃ»ÓÐÊÕµ½Êý¾Ý
 216   1          {
 217   2              // Èç¹û³¬Ê±
 218   2              // uart0_sendstr("Time out!\n");
 219   2      
 220   2              tmr0_disable(); // ¹Ø±Õ¶¨Ê±Æ÷
 221   2              tmr0_cnt = 0;   // Çå¿Õ¶¨Ê±Æ÷¼ÆÊýÖµ
 222   2      
 223   2              // µ±Ç°µÄÊý¾ÝÖ¡×÷·Ï
 224   2              cur_recv_len = 0;         // µ±Ç°½ÓÊÕµ½µÄÖ¡µÄ³¤¶ÈÇåÁã
 225   2              frame_len = 0;            // Òª½ÓÊÕµÄÖ¡µÄ³¤¶È£¬ÇåÁã
 226   2              flag_is_recving_data = 0; // ÖØÐÂ¿ªÊ¼½ÓÊÕÊý¾Ý
 227   2      
 228   2              // if (0 == recved_flagbuf[blank_index])
 229   2              // {
 230   2              //     memset(uart0_recv_buf[blank_index], 0, FRAME_MAX_LEN); // Çå¿Õ³¬Ê±µÄÖ¸Áî¶ÔÓ¦µÄ½ÓÊÕ»º³åÇø
 231   2              // }
 232   2      
 233   2      #if USE_MY_DEBUG
 234   2              printf("recv time out! \n");
 235   2      #endif
 236   2      
 237   2      #if 0
C51 COMPILER V9.60.7.0   UART0                                                             10/28/2024 17:51:21 PAGE 5   

                      for (i = 0; i < (UART0_RXBUF_LEN) / (FRAME_MAX_LEN); i++)
                      {
                          printf("%d :\t", i);
                          for (j = 0; j < FRAME_MAX_LEN; j++)
                          {
                              printf("%x ", uart0_recv_buf[i][j]);
                          }
                          printf("\n");
                      }
              #endif // MY_DEBUG
 248   2      
 249   2              return;
 250   2          }
 251   1      #endif // ½ÓÊÕ³¬Ê±´¦Àí
 252   1      
 253   1          // ¶ÔÊÕµ½µÄÊý¾ÝÖ¡½øÐÐÑéÖ¤
 254   1          for (i = 0; i < ((UART0_RXBUF_LEN) / (FRAME_MAX_LEN)); i++)
 255   1          {
 256   2              if (recved_flagbuf[i])
 257   2              {
 258   3                  // Èç¹û¶ÔÓ¦µÄÎ»ÖÃÓÐÍêÕûµÄÊý¾ÝÖ¡
 259   3      
 260   3                  if (uart0_recv_len[i] != uart0_recv_buf[i][1])
 261   3                  {
 262   4      // Èç¹ûÊý¾ÝÖ¡µÄ³¤¶È²»ÕýÈ·
 263   4      #if USE_MY_DEBUG
 264   4                      printf("format len invalid!\n");
 265   4      #endif
 266   4                      // flag_is_recving_data = 0;
 267   4                      recved_flagbuf[i] = 0;
 268   4                      recv_frame_cnt--;
 269   4                      memset(uart0_recv_buf[i], 0, FRAME_MAX_LEN);
 270   4      
 271   4                      // for (i = 0; i < (UART0_RXBUF_LEN) / (FRAME_MAX_LEN); i++)
 272   4                      // {
 273   4                      //     uart0_sendbyte(i + '0');
 274   4                      //     uart0_sendbyte('\n');
 275   4                      //     uart0_sendnums(uart0_recv_buf[i], FRAME_MAX_LEN);
 276   4                      //     uart0_sendstr("\n==========================\n");
 277   4                      // }
 278   4      
 279   4                      return;
 280   4                  }
 281   3      
 282   3                  {                          // ¼ÆËãÐ£ÑéºÍ
 283   4                      u8 __loop_crc_cnt = 0; // ÓÃÓÚ¼ÆËãÐ£ÑéºÍµÄÑ­»·¼ÆÊýÖµ
 284   4                      checksum = 0;
 285   4                      for (__loop_crc_cnt = 0; __loop_crc_cnt < (uart0_recv_len[i] - 1); __loop_crc_cnt++)
 286   4                      {
 287   5                          checksum += uart0_recv_buf[i][__loop_crc_cnt];
 288   5                      }
 289   4      
 290   4                      checksum &= 0x0F;
 291   4                      if (checksum != uart0_recv_buf[i][uart0_recv_len[i] - 1])
 292   4                      {
 293   5                          // Èç¹û¼ÆËãµÄÐ£ÑéºÍÓëÊÕµ½µÄÐ£ÑéºÍ²»Ò»ÖÂ
 294   5                          __flag_is_crc_or_len_err = 1;
 295   5                      }
 296   4                  } // ¼ÆËãÐ£ÑéºÍ
 297   3      
 298   3                  if (__flag_is_crc_or_len_err)
 299   3                  {
C51 COMPILER V9.60.7.0   UART0                                                             10/28/2024 17:51:21 PAGE 6   

 300   4      #if USE_MY_DEBUG
 301   4                      printf("recv crc or len err! \n");
 302   4      #endif
 303   4                      // flag_is_recving_data = 0;
 304   4                      __flag_is_crc_or_len_err = 0; //
 305   4                      recved_flagbuf[i] = 0;
 306   4                      recv_frame_cnt--;
 307   4                      memset(uart0_recv_buf[i], 0, FRAME_MAX_LEN); // Çå¿ÕÐ£ÑéºÍ´íÎóµÄÖ¸Áî¶ÔÓ¦µÄ»º³åÇø
 308   4                  }
 309   3      
 310   3                  // Èç¹ûÔËÐÐµ½ÕâÀï£¬Êý¾Ý¶¼Õý³£
 311   3                  flagbuf_valid_instruction[i] = 1; // ¶ÔÓ¦µÄ±êÖ¾Î»ÖÃÒ»£¬±íÊ¾ÊÕµ½ÁËºÏ·¨µÄÖ¸Áî
 312   3              } // if (recved_flagbuf[i])
 313   2          } // for (i = 0; i < ((UART0_RXBUF_LEN) / (FRAME_MAX_LEN)); i++)
 314   1      }
 315          
 316          void __uart_buff_check(void)
 317          {
 318   1          u8 i = 0;
 319   1          u8 j = 0;
 320   1          u8 k = 0;
 321   1          if (test_bit)
 322   1          {
 323   2              test_bit = 0;
 324   2              for (i = 0; i < (UART0_RXBUF_LEN) / (FRAME_MAX_LEN); i++)
 325   2              {
 326   3                  for (j = 0; j < (UART0_RXBUF_LEN) / (FRAME_MAX_LEN); j++)
 327   3                  {
 328   4                      uart0_sendbyte(j + '0');
 329   4                      uart0_sendbyte('\n');
 330   4                      for (k = 0; k < FRAME_MAX_LEN; k++)
 331   4                      {
 332   5                          printf("%2x ", (u16)uart0_recv_buf[j][k]);
 333   5                      }
 334   4      
 335   4                      printf("\n==========================\n");
 336   4                  }
 337   3              }
 338   2          }
 339   1      }
 340          
 341          #if 0
                          switch (uart0_recv_len[i])
                          {
                          case 4:
              
                              // Èç¹ûÊÇËÄ¸ö×Ö½ÚµÄÊý¾Ý
                              checksum = (uart0_recv_buf[i][0] + uart0_recv_buf[i][1] + uart0_recv_buf[i][2]) & 0x0F;
              
                              if (checksum != uart0_recv_buf[i][3])
                              {
                                  // Èç¹û¼ÆËãµÃ³öµÄÐ£ÑéºÍÓëÊý¾ÝÖ¡ÖÐµÄÐ£ÑéºÍ²»Ò»ÖÂ
                                  // ËµÃ÷´«ÊäµÄÊý¾ÝÓÐÎó
                                  // uart0_sendstr("checknum err_4Bytes\n");
                                  // recved_flagbuf[i] = 0;
                                  // recv_frame_cnt--;
                                  // memset(uart0_recv_buf[i], 0, FRAME_MAX_LEN);
                                  __flag_is_crc_or_len_err = 1;
                              }
              
                              break;
              
C51 COMPILER V9.60.7.0   UART0                                                             10/28/2024 17:51:21 PAGE 7   

                          case 5:
              
                              // Èç¹ûÊÇÎå¸ö×Ö½ÚµÄÊý¾Ý
                              checksum = (uart0_recv_buf[i][0] + uart0_recv_buf[i][1] + uart0_recv_buf[i][2] + uart0_rec
             -v_buf[i][3]) & 0x0F;
                              if (checksum != uart0_recv_buf[i][4])
                              {
                                  // Èç¹û¼ÆËãµÃ³öµÄÐ£ÑéºÍÓëÊý¾ÝÖ¡ÖÐµÄÐ£ÑéºÍ²»Ò»ÖÂ
                                  // ËµÃ÷´«ÊäµÄÊý¾ÝÓÐÎó
                                  // uart0_sendstr("checknum err_5Bytes\n");
                                  // recved_flagbuf[i] = 0;
                                  // recv_frame_cnt--;
                                  // memset(uart0_recv_buf[i], 0, FRAME_MAX_LEN);
                                  __flag_is_crc_or_len_err = 1;
                              }
              
                              break;
                          case 6:
              
                              // Èç¹ûÊÇÁù¸ö×Ö½ÚµÄÊý¾Ý
                              checksum = (uart0_recv_buf[i][0] + uart0_recv_buf[i][1] + uart0_recv_buf[i][2] + uart0_rec
             -v_buf[i][3] + uart0_recv_buf[i][4]) & 0x0F;
              
                              if (checksum != uart0_recv_buf[i][5])
                              {
                                  // Èç¹û¼ÆËãµÃ³öµÄÐ£ÑéºÍÓëÊý¾ÝÖ¡ÖÐµÄÐ£ÑéºÍ²»Ò»ÖÂ
                                  // ËµÃ÷´«ÊäµÄÊý¾ÝÓÐÎó
                                  // uart0_sendstr("checknum err_6Bytes\n");
                                  // recved_flagbuf[i] = 0;
                                  // recv_frame_cnt--;
                                  // memset(uart0_recv_buf[i], 0, FRAME_MAX_LEN);
                                  __flag_is_crc_or_len_err = 1;
                              }
              
                              break;
                          case 7: // Èç¹ûÊÇ7¸ö×Ö½ÚµÄÊý¾Ý
                              checksum = (uart0_recv_buf[i][0] + uart0_recv_buf[i][1] + uart0_recv_buf[i][2] + uart0_rec
             -v_buf[i][3] + uart0_recv_buf[i][4] + uart0_recv_buf[i][5]) & 0x0F;
                              if (checksum != uart0_recv_buf[i][6])
                              {
                                  // Èç¹û¼ÆËãµÃ³öµÄÐ£ÑéºÍÓëÊý¾ÝÖ¡ÖÐµÄÐ£ÑéºÍ²»Ò»ÖÂ
                                  // ËµÃ÷´«ÊäµÄÊý¾ÝÓÐÎó
                                  // recved_flagbuf[i] = 0;
                                  // recv_frame_cnt--;
              
                                  __flag_is_crc_or_len_err = 1;
                              }
                              break;
                          case 8: // Èç¹ûÊÇ8¸ö×Ö½ÚµÄÊý¾Ý
                              checksum = (uart0_recv_buf[i][0] + uart0_recv_buf[i][1] + uart0_recv_buf[i][2] + uart0_rec
             -v_buf[i][3] + uart0_recv_buf[i][4] + uart0_recv_buf[i][5] + uart0_recv_buf[i][6]) & 0x0F;
                              if (checksum != uart0_recv_buf[i][7])
                              {
                                  // Èç¹û¼ÆËãµÃ³öµÄÐ£ÑéºÍÓëÊý¾ÝÖ¡ÖÐµÄÐ£ÑéºÍ²»Ò»ÖÂ
                                  // ËµÃ÷´«ÊäµÄÊý¾ÝÓÐÎó
                                  // recved_flagbuf[i] = 0;
                                  // recv_frame_cnt--;
                                  __flag_is_crc_or_len_err = 1;
                              }
                              break;
              
                          default:
C51 COMPILER V9.60.7.0   UART0                                                             10/28/2024 17:51:21 PAGE 8   

                              // Èç¹û²»ÊÇËÄ¡¢Îå¡¢Áù¡¢Æß¡¢°Ë¸ö×Ö½ÚµÄÊý¾Ý£¬ËµÃ÷½ÓÊÕÓÐÎó£¬Ö±½ÓÅ×ÆúÕâÒ»Ö¡Êý¾Ý
              #if USE_MY_DEBUG
                              // printf("recv cnt err\n");
                              __flag_is_crc_or_len_err = 1;
              #endif
                              // recved_flagbuf[i] = 0;
                              // recv_frame_cnt--;
                              // memset(uart0_recv_buf[i], 0, FRAME_MAX_LEN);
              
                              break;
                          } // switch (uart0_recv_len[i])
              #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    996    ----
   CONSTANT SIZE    =     95    ----
   XDATA SIZE       =     46       8
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
