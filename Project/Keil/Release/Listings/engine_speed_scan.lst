C51 COMPILER V9.60.7.0   ENGINE_SPEED_SCAN                                                 10/26/2024 17:00:26 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE ENGINE_SPEED_SCAN
OBJECT MODULE PLACED IN .\Release\Objects\engine_speed_scan.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\engine_speed_scan.c LARGE OPTIMIZE(8,SIZE) BROWSE INTVECTOR(0
                    -X000C) INCDIR(..\..\Libraries\Include;..\..\User;..\..\User\lib;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\R
                    -elease\Listings\engine_speed_scan.lst) OBJECT(.\Release\Objects\engine_speed_scan.obj)

line level    source

   1          #include "engine_speed_scan.h"
   2          
   3          // 发动机每转一圈，能检测到的脉冲个数
   4          #ifndef ENGINE_PULSE_PER_TURN
   5          #define ENGINE_PULSE_PER_TURN 16
   6          #endif
   7          
   8          static volatile u32 pulse_cnt = 0; // 脉冲计数值
   9          
  10          // 发动机转速的相关配置
  11          void engine_speed_scan_config(void)
  12          {
  13   1      #ifdef DEVELOPMENT_BOARD
                  // 这里用P23来检测霍尔传感器的脉冲
                  // 使用IO中断来对脉冲计数
                  __SetIRQnIP(P2_IRQn, P2_IQn_CFG); // 设置中断优先级
                  __EnableIRQ(P2_IRQn);             // 使能P2中断
                  IE_EA = 1;                        // 使能总开关
              
                  P2_MD0 &= ~GPIO_P23_MODE_SEL(0x3); // 输入模式
                  P2_PD |= GPIO_P23_PULL_PD(0x1);    // 配置为下拉
                  P2_IMK |= GPIO_P23_IRQ_MASK(0x1);  // 使能IO中断
                  P2_TRG0 &= ~GPIO_P23_TRG_SEL(0x3);
                  P2_TRG0 |= GPIO_P23_TRG_SEL(0x2); // 配置上升沿触发
              #endif
  26   1      
  27   1      #ifdef CIRCUIT_BOARD
  28   1          // 使用IO中断来对脉冲计数
  29   1          __SetIRQnIP(P1_IRQn, P1_IQn_CFG); // 设置中断优先级
  30   1          __EnableIRQ(P1_IRQn);             // 使能P1中断
  31   1          IE_EA = 1;                        // 使能总开关
  32   1      
  33   1          P1_MD0 &= ~GPIO_P12_MODE_SEL(0x3); // 输入模式
  34   1          P1_PD |= GPIO_P12_PULL_PD(0x1);    // 配置为下拉
  35   1          P1_IMK |= GPIO_P12_IRQ_MASK(0x1);  // 使能IO中断
  36   1          P1_TRG0 &= ~GPIO_P12_TRG_SEL(0x3);
  37   1          P1_TRG0 |= GPIO_P12_TRG_SEL(0x2); // 配置上升沿触发
  38   1      #endif
  39   1      }
  40          
  41          // 获取发动机每分钟转速
  42          static u32 get_engine_speed_rpm(void)
  43          {
  44   1          // return (get_turns_per_250ms() * 4 * 60);
  45   1      
  46   1          u32 tmp = 0;
  47   1          pulse_cnt = 0;
  48   1          tmr1_cnt = 0;
  49   1          tmr1_enable();
  50   1      #ifdef DEVELOPMENT_BOARD
                  __EnableIRQ(P2_IRQn); // 使能P2中断
              #endif
  53   1      #ifdef CIRCUIT_BOARD
C51 COMPILER V9.60.7.0   ENGINE_SPEED_SCAN                                                 10/26/2024 17:00:26 PAGE 2   

  54   1          __EnableIRQ(P1_IRQn); // 使能中断
  55   1      #endif
  56   1      
  57   1          while (tmr1_cnt < 2500)
  58   1          {
  59   2          }; // 等待250ms
  60   1      
  61   1          // 计算出每min(250ms * 4 * 60 == 1min)转了多少圈
  62   1          tmp = pulse_cnt * 240 / ENGINE_PULSE_PER_TURN;
  63   1      
  64   1          tmr1_disable();
  65   1      #ifdef DEVELOPMENT_BOARD
                  __DisableIRQ(P2_IRQn); // 禁用P2中断
              #endif
  68   1      #ifdef CIRCUIT_BOARD
  69   1          __DisableIRQ(P1_IRQn); // 禁用中断
  70   1      #endif
  71   1          tmr1_cnt = 0;
  72   1          pulse_cnt = 0;
  73   1      
  74   1          return tmp;
  75   1      }
  76          
  77          // 发动机转速扫描
  78          void engine_speed_scan(void)
  79          {
  80   1          u32 rpm = get_engine_speed_rpm();
  81   1          // printf("rpm: %lu\n", rpm);
  82   1      
  83   1          fun_info.engine_speeed = rpm;
  84   1          get_engine_speed = 1;
  85   1      }
  86          
  87          #ifdef DEVELOPMENT_BOARD
              // P2中断服务函数
              void P2_IRQHandler(void) interrupt P2_IRQn
              {
                  // Px_PND寄存器写任何值都会清标志位
                  u8 p2_pnd = P2_PND;
              
                  // 进入中断设置IP，不可删除
                  __IRQnIPnPush(P2_IRQn);
                  // ---------------- 用户函数处理 -------------------
              
                  if (p2_pnd & GPIO_P23_IRQ_PNG(0x1))
                  {
                      pulse_cnt++;
                  }
                  P2_PND = p2_pnd; // 清P2中断标志位
              
                  // -------------------------------------------------
                  // 退出中断设置IP，不可删除
                  __IRQnIPnPop(P2_IRQn);
              }
              #endif
 109          
 110          #ifdef CIRCUIT_BOARD
 111          // P1中断服务函数
 112          void P1_IRQHandler(void) interrupt P1_IRQn
 113          {
 114   1          // Px_PND寄存器写任何值都会清标志位
 115   1          u8 p1_pnd = P1_PND;
C51 COMPILER V9.60.7.0   ENGINE_SPEED_SCAN                                                 10/26/2024 17:00:26 PAGE 3   

 116   1      
 117   1          // 进入中断设置IP，不可删除
 118   1          __IRQnIPnPush(P1_IRQn);
 119   1          // ---------------- 用户函数处理 -------------------
 120   1      
 121   1          if (p1_pnd & GPIO_P12_IRQ_PNG(0x1))
 122   1          {
 123   2              pulse_cnt++;
 124   2          }
 125   1          P1_PND = p1_pnd; // 清P1中断标志位
 126   1      
 127   1          // -------------------------------------------------
 128   1          // 退出中断设置IP，不可删除
 129   1          __IRQnIPnPop(P1_IRQn);
 130   1      }
 131          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    254    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      4       4
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
