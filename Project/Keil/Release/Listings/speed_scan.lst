C51 COMPILER V9.60.7.0   SPEED_SCAN                                                        11/08/2024 16:31:55 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE SPEED_SCAN
OBJECT MODULE PLACED IN .\Release\Objects\speed_scan.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\speed_scan.c LARGE OPTIMIZE(8,SIZE) BROWSE INTVECTOR(0X000C) 
                    -INCDIR(..\..\Libraries\Include;..\..\User;..\..\User\lib;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\
                    -Listings\speed_scan.lst) OBJECT(.\Release\Objects\speed_scan.obj)

line level    source

   1          #include "speed_scan.h"
   2          
   3          // ∂‡…Ÿ∏ˆ¬ˆ≥Â±Ì æ“ª»¶
   4          #ifndef PULSE_PER_TURN
   5          #define PULSE_PER_TURN 16
   6          #endif // ∂‡…Ÿ∏ˆ¬ˆ≥Â±Ì æ“ª»¶
   7          
   8          // ≥µ¬÷“ª»¶±Ì æ∂‡…Ÿ∫¡√◊
   9          #ifndef MM_PER_TURN
  10          #define MM_PER_TURN 1795 // “ª»¶1795∫¡√◊
  11          #endif                   // ≥µ¬÷“ª»¶±Ì æ∂‡…Ÿ∫¡√◊
  12          
  13          static volatile u32 pulse_cnt = 0; // ¬ˆ≥Âº∆ ˝÷µ
  14          volatile u32 distance = 0;         // ¥Ê∑≈√ø¥Œ…®√Ë ±◊ﬂπ˝µƒ¬∑≥Ã£®µ•Œª£∫∫¡√◊£©-->”√”⁄¿Ô≥Ã±Ìµƒº∆ ˝
  15          
  16          //  ±ÀŸ…®√Ëµƒ≈‰÷√
  17          void speed_scan_config(void)
  18          {
  19   1      #ifdef DEVELOPMENT_BOARD
                  //  π”√IO÷–∂œ¿¥∂‘¬ˆ≥Âº∆ ˝
                  __SetIRQnIP(P1_IRQn, P1_IQn_CFG); // …Ë÷√÷–∂œ”≈œ»º∂
                  __EnableIRQ(P1_IRQn);             //  πƒ‹P1÷–∂œ
                  IE_EA = 1;                        //  πƒ‹◊‹ø™πÿ
              
                  P1_MD0 &= ~GPIO_P13_MODE_SEL(0x3); //  ‰»Îƒ£ Ω
                  P1_PD |= GPIO_P13_PULL_PD(0x1);    // ≈‰÷√Œ™œ¬¿≠
                  P1_IMK |= GPIO_P13_IRQ_MASK(0x1);  //  πƒ‹IO÷–∂œ
                  P1_TRG0 &= ~GPIO_P13_TRG_SEL(0x3);
                  P1_TRG0 |= GPIO_P13_TRG_SEL(0x2); // ≈‰÷√…œ…˝—ÿ¥•∑¢
              #endif
  31   1      
  32   1      #ifdef CIRCUIT_BOARD
  33   1          //  π”√IO÷–∂œ¿¥∂‘¬ˆ≥Âº∆ ˝
  34   1          __SetIRQnIP(P0_IRQn, P0_IQn_CFG); // …Ë÷√÷–∂œ”≈œ»º∂
  35   1          __EnableIRQ(P0_IRQn);             //  πƒ‹P1÷–∂œ
  36   1          IE_EA = 1;                        //  πƒ‹◊‹ø™πÿ
  37   1      
  38   1          P0_MD0 &= ~GPIO_P02_MODE_SEL(0x3); //  ‰»Îƒ£ Ω
  39   1          P0_PD |= GPIO_P02_PULL_PD(0x1);    // ≈‰÷√Œ™œ¬¿≠
  40   1          P0_IMK |= GPIO_P02_IRQ_MASK(0x1);  //  πƒ‹IO÷–∂œ
  41   1          P0_TRG0 &= ~GPIO_P02_TRG_SEL(0x3);
  42   1          P0_TRG0 |= GPIO_P02_TRG_SEL(0x2); // ≈‰÷√…œ…˝—ÿ¥•∑¢
  43   1      #endif
  44   1      }
  45          
  46          // πÿ±’ÀŸ∂»…®√Ëµƒœ‡πÿ÷–∂œ£¨«Âø’œ‡πÿµƒº∆ ˝
  47          static void speed_scan_disable(void)
  48          {
  49   1      #ifdef DEVELOPMENT_BOARD
                  __DisableIRQ(P1_IRQn); // πÿ±’P1÷–∂œ
              #endif
  52   1      #ifdef CIRCUIT_BOARD
  53   1          __DisableIRQ(P0_IRQn); // πÿ±’P0÷–∂œ
C51 COMPILER V9.60.7.0   SPEED_SCAN                                                        11/08/2024 16:31:55 PAGE 2   

  54   1      #endif
  55   1          pulse_cnt = 0; // «Âø’¬ˆ≥Âº∆ ˝
  56   1          tmr1_disable();
  57   1          tmr1_cnt = 0;
  58   1      }
  59          
  60          // ø™∆ÙÀŸ∂»…®√Ëœ‡πÿµƒ÷–∂œ
  61          static void speed_scan_enable(void)
  62          {
  63   1          pulse_cnt = 0;
  64   1          tmr1_cnt = 0;
  65   1      #ifdef DEVELOPMENT_BOARD
                  __EnableIRQ(P1_IRQn); //  πƒ‹P1÷–∂œ
              #endif
  68   1      #ifdef CIRCUIT_BOARD
  69   1          __EnableIRQ(P0_IRQn); //  πƒ‹P0÷–∂œ
  70   1      #endif
  71   1      
  72   1          tmr1_enable();
  73   1      }
  74          
  75          // ªÒ»°√ø–° ±◊ﬂπ˝∂‡…Ÿ∫¡√◊
  76          static u32 get_speed_mm_per_hour(void)
  77          {
  78   1          u32 tmp = 0;
  79   1          speed_scan_enable();
  80   1          while (tmr1_cnt < 2500)
  81   1              ;                                           // µ»¥˝250ms
  82   1          tmp = pulse_cnt * MM_PER_TURN / PULSE_PER_TURN; // 250ms◊ﬂπ˝¿¥∂‡…Ÿ∫¡√◊
  83   1          distance += tmp;                                // ¥Ê∑≈◊ﬂπ˝µƒæ‡¿Î£¨µ•Œª£∫∫¡√◊(“ÚŒ™√ª”– π”√∏°µ„¿‡–Õ,–Ë“
             -™¿€º”,∑Ò‘Ú∫Û–¯Õ≥º∆¿Ô≥Ã ±æÕª·∂™ ß ˝æ›)
  84   1          speed_scan_disable();
  85   1          tmp *= 14400; // º∆À„µ√≥ˆ1–° ±◊ﬂπ˝µƒ∫¡√◊     // tmp = tmp * 4 * 3600;
  86   1          return tmp;
  87   1      }
  88          
  89          // ≤…ºØ“ª¥ŒÀŸ∂» ˝æ›
  90          static u32 get_speed(void)
  91          {
  92   1      #if 0
                  u32 speed_km_per_hour = get_speed_mm_per_hour(); // µ√µΩ√ø–° ±◊ﬂπ˝µƒ∫¡√◊ ˝
                  // speed_km_per_hour /= 1000000;                  // ªªÀ„≥…√ø–° ±◊ﬂπ˝µƒ«ß√◊ ˝
                  return speed_km_per_hour / 1000000;
              #endif
  97   1      
  98   1          return (get_speed_mm_per_hour() / 1000000);
  99   1      }
 100          
 101          // ÀŸ∂»…®√Ë∫Ø ˝£¨“—æ≠—È÷§ø…“‘ π”√
 102          void speed_scan(void)
 103          {
 104   1          static u32 last_speed = 0;   // º«¬º…œ“ª¥Œ≤…ºØµΩµƒÀŸ∂»
 105   1          u32 cur_speed = get_speed(); // µ±«∞≤…ºØµƒÀŸ∂»
 106   1          // printf("--------%lu km/h\n", cur_speed);
 107   1      
 108   1          if (((cur_speed > last_speed) && (cur_speed - last_speed > 2)) ||
 109   1              ((cur_speed < last_speed) && (last_speed - cur_speed > 2)))
 110   1          {
 111   2      // »Áπ˚±æ¥Œ≤…ºØµΩµƒ ˝æ›”Î…œ“ª¥Œ≤…ºØµΩµƒ ˝æ›≤Ó÷µ≥¨π˝¡À1£¨ø…“‘÷±Ω”∑¢ÀÕ≥ˆ»•
 112   2      
 113   2              // ≤‚ ‘”√£∫
 114   2              // printf("%lu km/h\n", cur_speed);
C51 COMPILER V9.60.7.0   SPEED_SCAN                                                        11/08/2024 16:31:55 PAGE 3   

 115   2      
 116   2              last_speed = cur_speed;
 117   2      
 118   2              fun_info.speed = cur_speed;
 119   2              flag_get_speed = 1;
 120   2          }
 121   1          else if (((cur_speed > last_speed) && (cur_speed - last_speed < 2)) ||
 122   1                   ((cur_speed < last_speed) && (last_speed - cur_speed < 2)))
 123   1          {
 124   2              // »Áπ˚±æ¥Œ≤…ºØµΩµƒ ˝æ›”Î…œ“ª¥Œ≤…ºØµΩµƒ ˝æ›≤Ó÷µ÷ª”–1£¨‘Ÿ≤…ºØº∏¥Œ
 125   2              u8 cnt = 0;
 126   2      
 127   2              if ((cur_speed > last_speed) && (cur_speed - last_speed < 2))
 128   2              {
 129   3                  // »Áπ˚≤‚µ√ÀŸ∂» «‘ˆº”µƒ£¨“™»∑∂®À¸ «’Êµƒ‘⁄º”ÀŸ
 130   3                  u8 i = 0;
 131   3      
 132   3                  for (i = 0; i < 3; i++)
 133   3                  {
 134   4                      cur_speed = get_speed();
 135   4      
 136   4                      if ((cur_speed > last_speed) && (cur_speed - last_speed < 2))
 137   4                      {
 138   5                          cnt++;
 139   5                      }
 140   4                  }
 141   3              }
 142   2              else if ((cur_speed < last_speed) && (last_speed - cur_speed < 2))
 143   2              {
 144   3                  // »Áπ˚≤‚µ√ÀŸ∂» «ºı…Ÿµƒ£¨“™»∑∂®À¸ «’Êµƒ‘⁄ºıÀŸ
 145   3                  u8 i = 0;
 146   3                  for (i = 0; i < 3; i++)
 147   3                  {
 148   4                      cur_speed = get_speed();
 149   4      
 150   4                      if ((cur_speed < last_speed) && (last_speed - cur_speed < 2))
 151   4                      {
 152   5                          cnt++;
 153   5                      }
 154   4                  }
 155   3              }
 156   2      
 157   2              if (cnt >= 2)
 158   2              {
 159   3                  // ≤‚ ‘”√£∫
 160   3                  // printf("%lu km/h\n", cur_speed);
 161   3      
 162   3                  last_speed = cur_speed;
 163   3      
 164   3                  fun_info.speed = cur_speed;
 165   3                  flag_get_speed = 1;
 166   3              }
 167   2          }
 168   1          else if (cur_speed == 0 && last_speed != 0)
 169   1          {
 170   2              // ≤‚ ‘”√£∫
 171   2              // printf("%lu km/h\n", cur_speed);
 172   2      
 173   2      
 174   2              fun_info.speed = cur_speed;
 175   2              flag_get_speed = 1;
 176   2          }
C51 COMPILER V9.60.7.0   SPEED_SCAN                                                        11/08/2024 16:31:55 PAGE 4   

 177   1      }
 178          
 179          #ifdef DEVELOPMENT_BOARD
              // P1÷–∂œ∑˛ŒÒ∫Ø ˝
              void P1_IRQHandler(void) interrupt P1_IRQn
              {
                  // Px_PNDºƒ¥Ê∆˜–¥»Œ∫Œ÷µ∂ºª·«Â±Í÷æŒª
                  u8 p1_pnd = P1_PND;
              
                  // Ω¯»Î÷–∂œ…Ë÷√IP£¨≤ªø……æ≥˝
                  __IRQnIPnPush(P1_IRQn);
                  // ---------------- ”√ªß∫Ø ˝¥¶¿Ì -------------------
                  if (p1_pnd & GPIO_P13_IRQ_PNG(0x1))
                  {
                      pulse_cnt++;
                  }
                  P1_PND = p1_pnd; // «ÂP1÷–∂œ±Í÷æŒª
                  // -------------------------------------------------
                  // ÕÀ≥ˆ÷–∂œ…Ë÷√IP£¨≤ªø……æ≥˝
                  __IRQnIPnPop(P1_IRQn);
              }
              #endif
 199          
 200          #ifdef CIRCUIT_BOARD
 201          // P0÷–∂œ∑˛ŒÒ∫Ø ˝
 202          void P0_IRQHandler(void) interrupt P0_IRQn
 203          {
 204   1          // Px_PNDºƒ¥Ê∆˜–¥»Œ∫Œ÷µ∂ºª·«Â±Í÷æŒª
 205   1          u8 p0_pnd = P0_PND;
 206   1      
 207   1          // Ω¯»Î÷–∂œ…Ë÷√IP£¨≤ªø……æ≥˝
 208   1          __IRQnIPnPush(P0_IRQn);
 209   1          // ---------------- ”√ªß∫Ø ˝¥¶¿Ì -------------------
 210   1          if (p0_pnd & GPIO_P02_IRQ_PNG(0x1))
 211   1          {
 212   2              pulse_cnt++;
 213   2          }
 214   1          P0_PND = p0_pnd; // «ÂP0÷–∂œ±Í÷æŒª
 215   1          // -------------------------------------------------
 216   1          // ÕÀ≥ˆ÷–∂œ…Ë÷√IP£¨≤ªø……æ≥˝
 217   1          __IRQnIPnPop(P0_IRQn);
 218   1      }
 219          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    829    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     12      10
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
