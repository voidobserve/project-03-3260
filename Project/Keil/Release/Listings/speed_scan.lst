C51 COMPILER V9.60.7.0   SPEED_SCAN                                                        11/18/2024 17:39:07 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE SPEED_SCAN
OBJECT MODULE PLACED IN .\Release\Objects\speed_scan.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\User\speed_scan.c LARGE OPTIMIZE(8,SIZE) BROWSE INTVECTOR(0X000C) 
                    -INCDIR(..\..\Libraries\Include;..\..\User;..\..\User\lib;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\
                    -Listings\speed_scan.lst) OBJECT(.\Release\Objects\speed_scan.obj)

line level    source

   1          #include "speed_scan.h"
   2          
   3          // å¤šå°‘ä¸ªè„‰å†²è¡¨ç¤ºä¸€åœˆ
   4          #ifndef PULSE_PER_TURN
   5          #define PULSE_PER_TURN 16
   6          #endif // å¤šå°‘ä¸ªè„‰å†²è¡¨ç¤ºä¸€åœˆ
   7          
   8          // è½¦è½®ä¸€åœˆè¡¨ç¤ºå¤šå°‘æ¯«ç±³
   9          #ifndef MM_PER_TURN
  10          #define MM_PER_TURN 1795 // ä¸€åœˆ1795æ¯«ç±³
  11          #endif                   // è½¦è½®ä¸€åœˆè¡¨ç¤ºå¤šå°‘æ¯«ç±³
  12          
  13          static volatile u32 pulse_cnt = 0; // è„‰å†²è®¡æ•°å€¼
  14          volatile u32 distance = 0;         // å­˜æ”¾æ¯æ¬¡æ‰«ææ—¶èµ°è¿‡çš„è·¯ç¨‹ï¼ˆå•ä½ï¼šæ¯«ç±³ï¼‰-->ç”¨äºé‡
             -Œç¨‹è¡¨çš„è®¡æ•°
  15          
  16          // æ—¶é€Ÿæ‰«æçš„é…ç½®
  17          void speed_scan_config(void)
  18          {
  19   1          // ä½¿ç”¨IOä¸­æ–­æ¥å¯¹è„‰å†²è®¡æ•°
  20   1          __SetIRQnIP(P0_IRQn, P0_IQn_CFG); // è®¾ç½®ä¸­æ–­ä¼˜å…ˆçº§
  21   1          __EnableIRQ(P0_IRQn);             // ä½¿èƒ½P1ä¸­æ–­
  22   1          IE_EA = 1;                        // ä½¿èƒ½æ€»å¼€å…³
  23   1      
  24   1          P0_MD0 &= ~GPIO_P02_MODE_SEL(0x3); // è¾“å…¥æ¨¡å¼
  25   1          P0_PD |= GPIO_P02_PULL_PD(0x1);    // é…ç½®ä¸ºä¸‹æ‹‰
  26   1          P0_IMK |= GPIO_P02_IRQ_MASK(0x1);  // ä½¿èƒ½IOä¸­æ–­
  27   1          P0_TRG0 &= ~GPIO_P02_TRG_SEL(0x3);
  28   1          P0_TRG0 |= GPIO_P02_TRG_SEL(0x2); // é…ç½®ä¸Šå‡æ²¿è§¦å‘
  29   1      }
  30          
  31          // // å…³é—­é€Ÿåº¦æ‰«æçš„ç›¸å…³ä¸­æ–­ï¼Œæ¸…ç©ºç›¸å…³çš„è®¡æ•°
  32          // static void speed_scan_disable(void)
  33          // {
  34          
  35          //     __DisableIRQ(P0_IRQn); // å…³é—­P0ä¸­æ–­
  36          
  37          //     pulse_cnt = 0; // æ¸…ç©ºè„‰å†²è®¡æ•°
  38          //     tmr1_disable();
  39          //     tmr1_cnt = 0;
  40          // }
  41          
  42          // // å¼€å¯é€Ÿåº¦æ‰«æç›¸å…³çš„ä¸­æ–­
  43          // static void speed_scan_enable(void)
  44          // {
  45          //     pulse_cnt = 0;
  46          //     tmr1_cnt = 0;
  47          
  48          //     __EnableIRQ(P0_IRQn); // ä½¿èƒ½P0ä¸­æ–­
  49          
  50          //     tmr1_enable();
  51          // }
  52          
C51 COMPILER V9.60.7.0   SPEED_SCAN                                                        11/18/2024 17:39:07 PAGE 2   

  53          // è·å–æ¯å°æ—¶èµ°è¿‡å¤šå°‘æ¯«ç±³
  54          // static u32 get_speed_mm_per_hour(void)
  55          // {
  56          //     // u32 tmp = 0;
  57          //     // speed_scan_enable();
  58          //     // while (tmr1_cnt < 2500)
  59          //     //     ;                                           // ç­‰å¾…250ms
  60          //     // tmp = pulse_cnt * MM_PER_TURN / PULSE_PER_TURN; // 250msèµ°è¿‡æ¥å¤šå°‘æ¯«ç±³
  61          //     // distance += tmp;                                // å­˜æ”¾èµ°è¿‡çš„è·ç¦»ï¼Œå•ä½ï¼šæ¯«ç±³(å› ä¸
             -ºæ²¡æœ‰ä½¿ç”¨æµ®ç‚¹ç±»å‹,éœ€è¦ç´¯åŠ ,å¦åˆ™åç»­ç»Ÿè®¡é‡Œç¨‹æ—¶å°±ä¼šä¸¢å¤±æ•°æ®)
  62          //     // speed_scan_disable();
  63          //     // tmp *= 14400; // è®¡ç®—å¾—å‡º1å°æ—¶èµ°è¿‡çš„æ¯«ç±³     // tmp = tmp * 4 * 3600;
  64          //     // return tmp;
  65          
  66          //     u32 tmp = 0;
  67          //     if (tmr2_cnt >= 2500) // å¦‚æœç»è¿‡äº†250ms
  68          //     {
  69          //         // è®¡ç®—250mså†…èµ°è¿‡äº†å¤šå°‘æ¯«ç±³
  70          //         tmp = pulse_cnt *MM_PER_TURN / PULSE_PER_TURN
  71          //                                            distance += tmp; // å­˜æ”¾èµ°è¿‡çš„è·ç¦»ï¼Œå•ä½ï¼šæ¯«ç±³(
             -å› ä¸ºæ²¡æœ‰ä½¿ç”¨æµ®ç‚¹ç±»å‹,éœ€è¦ç´¯åŠ ,å¦åˆ™åç»­ç»Ÿè®¡é‡Œç¨‹æ—¶å°±ä¼šä¸¢å¤±æ•°æ®)
  72          //         // è®¡ç®—å¾—å‡º1å°æ—¶èƒ½èµ°è¿‡å¤šå°‘æ¯«ç±³
  73          //         // tmp = tmp * 4 * 3600;
  74          //         tmp *= 14400;
  75          
  76          //         pulse_cnt = 0;
  77          //         tmr2_cnt = 0;
  78          //     }
  79          // }
  80          
  81          // // é‡‡é›†ä¸€æ¬¡é€Ÿåº¦æ•°æ®
  82          // static u32 get_speed(void)
  83          // {
  84          // #if 0
  85          //     u32 speed_km_per_hour = get_speed_mm_per_hour(); // å¾—åˆ°æ¯å°æ—¶èµ°è¿‡çš„æ¯«ç±³æ•°
  86          //     // speed_km_per_hour /= 1000000;                  // æ¢ç®—æˆæ¯å°æ—¶èµ°è¿‡çš„åƒç±³æ•°
  87          //     return speed_km_per_hour / 1000000;
  88          // #endif
  89          
  90          //     return (get_speed_mm_per_hour() / 1000000); // æ¢ç®—æˆ km
  91          // }
  92          
  93          // é€Ÿåº¦æ‰«æå‡½æ•°
  94          void speed_scan(void)
  95          {
  96   1          static u32 last_speed = 0;                  // è®°å½•ä¸Šä¸€æ¬¡é‡‡é›†åˆ°çš„é€Ÿåº¦
  97   1      
  98   1          static u8 speed_increases_cnt = 0; // æ£€æµ‹é€Ÿåº¦æ˜¯å¦åœ¨å¢åŠ çš„è®¡æ•°å€¼
  99   1          static u8 speed_decreases_cnt = 0; // æ£€æµ‹é€Ÿåº¦æ˜¯å¦åœ¨å‡å°‘çš„è®¡æ•°å€¼
 100   1      
 101   1          u32 cur_speed = 0; // è®°å½•å½“å‰é‡‡é›†åˆ°çš„é€Ÿåº¦
 102   1      
 103   1          if (tmr2_cnt >= 1000) // å¦‚æœç»è¿‡äº†100ms
 104   1          {
 105   2              tmr2_cnt = 0; // æ¸…é™¤å®šæ—¶å™¨è®¡æ•°
 106   2              // è®¡ç®—1000mså†…èµ°è¿‡äº†å¤šå°‘æ¯«ç±³
 107   2              // è„‰å†²ä¸ªæ•° / ä¸€åœˆæœ‰å¤šå°‘ä¸ªè„‰å†² * ä¸€åœˆè¡¨ç¤ºèµ°è¿‡äº†å¤šå°‘mm == è¯¥æ®µæ—¶é—´å†…èµ°è¿
             -‡çš„è·ç¦»(å•ä½:mm)
 108   2              cur_speed = pulse_cnt * MM_PER_TURN / PULSE_PER_TURN;
 109   2              distance += cur_speed; // å­˜æ”¾èµ°è¿‡çš„è·ç¦»ï¼Œå•ä½ï¼šæ¯«ç±³(å› ä¸ºæ²¡æœ‰ä½¿ç”¨æµ®ç‚¹ç±»å‹,é
             -œ€è¦ç´¯åŠ ,å¦åˆ™åç»­ç»Ÿè®¡é‡Œç¨‹æ—¶å°±ä¼šä¸¢å¤±æ•°æ®)
 110   2              // è®¡ç®—å¾—å‡º1å°æ—¶èƒ½èµ°è¿‡å¤šå°‘æ¯«ç±³
C51 COMPILER V9.60.7.0   SPEED_SCAN                                                        11/18/2024 17:39:07 PAGE 3   

 111   2              // tmp = tmp * 4 * 3600;
 112   2              cur_speed *= 14400;
 113   2              cur_speed /= 1000000; // æ¢ç®—æˆ km/hçš„å•ä½
 114   2      
 115   2              // u32 cur_speed = get_speed(); // å½“å‰é‡‡é›†çš„é€Ÿåº¦
 116   2              // printf("--------%lu km/h\n", cur_speed);
 117   2      
 118   2              pulse_cnt = 0; // æ¸…é™¤è„‰å†²è®¡æ•°
 119   2      
 120   2              if (cur_speed > last_speed)
 121   2              {
 122   3                  speed_decreases_cnt = 0;
 123   3                  speed_increases_cnt++;
 124   3      
 125   3                  if (speed_increases_cnt >= 10)
 126   3                  {
 127   4                      last_speed = cur_speed;
 128   4      
 129   4                      fun_info.speed = cur_speed;
 130   4                      flag_get_speed = 1;
 131   4                  }
 132   3              }
 133   2              else if (cur_speed < last_speed)
 134   2              {
 135   3                  speed_increases_cnt = 0;
 136   3                  speed_decreases_cnt++;
 137   3                  if (speed_decreases_cnt >= 10)
 138   3                  {
 139   4                      last_speed = cur_speed;
 140   4      
 141   4                      fun_info.speed = cur_speed;
 142   4                      flag_get_speed = 1;
 143   4                  }
 144   3              }
 145   2              else
 146   2              {
 147   3                  // å¦‚æœé€Ÿåº¦æœªå‘ç”Ÿå˜åŒ–
 148   3                  speed_increases_cnt = 0;
 149   3                  speed_decreases_cnt = 0;
 150   3              }
 151   2      
 152   2      
 153   2      #if 0
                      { // æ¯”å¯¹å¤šæ¬¡æ£€æµ‹åˆ°çš„é€Ÿåº¦ï¼Œç¡®è®¤é€Ÿåº¦æ˜¯åœ¨å˜åŒ–çš„ï¼Œæ‰æ›´æ–°ä¿¡æ¯
                          if (((cur_speed > last_speed) && (cur_speed - last_speed > 2)) ||
                              ((cur_speed < last_speed) && (last_speed - cur_speed > 2)))
                          {
                              // å¦‚æœæœ¬æ¬¡é‡‡é›†åˆ°çš„æ•°æ®ä¸ä¸Šä¸€æ¬¡é‡‡é›†åˆ°çš„æ•°æ®å·®å€¼è¶…è¿‡äº†1ï¼Œå¯ä»¥ç›
             -´æ¥å‘é€å‡ºå»
              
                              // æµ‹è¯•ç”¨ï¼š
                              // printf("%lu km/h\n", cur_speed);
              
                              last_speed = cur_speed;
              
                              fun_info.speed = cur_speed;
                              flag_get_speed = 1;
                          }
                          else if (((cur_speed > last_speed) && (cur_speed - last_speed < 2)) ||
                                   ((cur_speed < last_speed) && (last_speed - cur_speed < 2)))
                          {
                              // å¦‚æœæœ¬æ¬¡é‡‡é›†åˆ°çš„æ•°æ®ä¸ä¸Šä¸€æ¬¡é‡‡é›†åˆ°çš„æ•°æ®å·®å€¼åªæœ‰1ï¼Œå†é‡‡é›†å‡
C51 COMPILER V9.60.7.0   SPEED_SCAN                                                        11/18/2024 17:39:07 PAGE 4   

             - æ¬¡
                              u8 cnt = 0;
              
                              if ((cur_speed > last_speed) && (cur_speed - last_speed < 2))
                              {
                                  // å¦‚æœæµ‹å¾—é€Ÿåº¦æ˜¯å¢åŠ çš„ï¼Œè¦ç¡®å®šå®ƒæ˜¯çœŸçš„åœ¨åŠ é€Ÿ
                                  u8 i = 0;
              
                                  for (i = 0; i < 3; i++)
                                  {
                                      cur_speed = get_speed();
              
                                      if ((cur_speed > last_speed) && (cur_speed - last_speed < 2))
                                      {
                                          cnt++;
                                      }
                                  }
                              }
                              else if ((cur_speed < last_speed) && (last_speed - cur_speed < 2))
                              {
                                  // å¦‚æœæµ‹å¾—é€Ÿåº¦æ˜¯å‡å°‘çš„ï¼Œè¦ç¡®å®šå®ƒæ˜¯çœŸçš„åœ¨å‡é€Ÿ
                                  u8 i = 0;
                                  for (i = 0; i < 3; i++)
                                  {
                                      cur_speed = get_speed();
              
                                      if ((cur_speed < last_speed) && (last_speed - cur_speed < 2))
                                      {
                                          cnt++;
                                      }
                                  }
                              }
              
                              if (cnt >= 2)
                              {
                                  // æµ‹è¯•ç”¨ï¼š
                                  // printf("%lu km/h\n", cur_speed);
              
                                  last_speed = cur_speed;
              
                                  fun_info.speed = cur_speed;
                                  flag_get_speed = 1;
                              }
                          }
                          else if (cur_speed == 0 && last_speed != 0)
                          {
                              // æµ‹è¯•ç”¨ï¼š
                              // printf("%lu km/h\n", cur_speed);
              
                              fun_info.speed = cur_speed;
                              flag_get_speed = 1;
                          }
                      } // æ¯”å¯¹å¤šæ¬¡æ£€æµ‹åˆ°çš„é€Ÿåº¦ï¼Œç¡®è®¤é€Ÿåº¦æ˜¯åœ¨å˜åŒ–çš„ï¼Œæ‰æ›´æ–°ä¿¡æ¯
              #endif
 225   2          }
 226   1      }
 227          
 228          // P0ä¸­æ–­æœåŠ¡å‡½æ•°
 229          void P0_IRQHandler(void) interrupt P0_IRQn
 230          {
 231   1          // Px_PNDå¯„å­˜å™¨å†™ä»»ä½•å€¼éƒ½ä¼šæ¸…æ ‡å¿—ä½
 232   1          u8 p0_pnd = P0_PND;
C51 COMPILER V9.60.7.0   SPEED_SCAN                                                        11/18/2024 17:39:07 PAGE 5   

 233   1      
 234   1          // è¿›å…¥ä¸­æ–­è®¾ç½®IPï¼Œä¸å¯åˆ é™¤
 235   1          __IRQnIPnPush(P0_IRQn);
 236   1          // ---------------- ç”¨æˆ·å‡½æ•°å¤„ç† -------------------
 237   1          if (p0_pnd & GPIO_P02_IRQ_PNG(0x1))
 238   1          {
 239   2              pulse_cnt++;
 240   2          }
 241   1          P0_PND = p0_pnd; // æ¸…P0ä¸­æ–­æ ‡å¿—ä½
 242   1          // -------------------------------------------------
 243   1          // é€€å‡ºä¸­æ–­è®¾ç½®IPï¼Œä¸å¯åˆ é™¤
 244   1          __IRQnIPnPop(P0_IRQn);
 245   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    378    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     14       4
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
