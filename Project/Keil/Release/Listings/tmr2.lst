C51 COMPILER V9.60.7.0   TMR2                                                              11/18/2024 17:39:06 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE TMR2
OBJECT MODULE PLACED IN .\Release\Objects\tmr2.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\..\Hardware\tmr2.c LARGE OPTIMIZE(8,SIZE) BROWSE INTVECTOR(0X000C) IN
                    -CDIR(..\..\Libraries\Include;..\..\User;..\..\User\lib;..\..\Hardware) INTERVAL(3) DEBUG OBJECTEXTEND PRINT(.\Release\Li
                    -stings\tmr2.lst) OBJECT(.\Release\Objects\tmr2.obj)

line level    source

   1          // 定时器TMR2的驱动源文件
   2          #include "tmr2.h"
   3          
   4          // 定时器定时周期 (单位:Hz)
   5          // 周期值 = 系统时钟 / 定时器分频 / 频率 - 1
   6          #define TMR2_PERIOD (SYSCLK / 128 / 10000 - 1) // 10000Hz,100us
   7          
   8          volatile u32 tmr2_cnt = 0; // 定时器TMR2的计数值（每次在中断服务函数中会加一）
   9          
  10          /**
  11           * @brief 配置定时器TMR2，配置完成后，定时器默认关闭
  12           */
  13          void tmr2_config(void)
  14          {
  15   1          __SetIRQnIP(TMR2_IRQn, TMR2_IQn_CFG); // 设置中断优先级
  16   1          __DisableIRQ(TMR2_IRQn);              // 禁用中断
  17   1          IE_EA = 1;                            // 打开总中断
  18   1      
  19   1          // 清除TMR2的计数值
  20   1          TMR2_CNTL = 0;
  21   1          TMR2_CNTH = 0;
  22   1      
  23   1          TMR2_CONL &= ~TMR_PRESCALE_SEL(0x07); // 清除TMR2的预分频配置寄存器
  24   1          TMR2_CONL |= TMR_PRESCALE_SEL(0x07);  // 定时器预分频
  25   1          TMR2_CONL &= ~TMR_MODE_SEL(0x03);     // 清除TMR2的模式配置寄存器
  26   1          TMR2_CONL |= TMR_MODE_SEL(0x01);      // 配置TMR2的模式为计数器模式，最后对系统时钟
             -的脉冲进行计数
  27   1      
  28   1          TMR2_CONH &= ~TMR_PRD_PND(0x01); // 清除TMR2的计数标志位，表示未完成计数
  29   1          TMR2_CONH |= TMR_PRD_IRQ_EN(1);  // 使能TMR2的计数中断
  30   1      
  31   1          // 配置TMR2的计数周期
  32   1          TMR2_PRH = TMR_PERIOD_VAL_H((TMR2_PERIOD >> 8) & 0xFF); // 周期值
  33   1          TMR2_PRL = TMR_PERIOD_VAL_L((TMR2_PERIOD >> 0) & 0xFF);
  34   1      
  35   1          TMR2_CONL &= ~(TMR_SOURCE_SEL(0x07)); // 清除TMR2的时钟源配置寄存器
  36   1          TMR2_CONL |= TMR_SOURCE_SEL(0x05);    // 配置TMR2的时钟源，不用任何时钟
  37   1      }
  38          
  39          /**
  40           * @brief 开启定时器TMR2，开始计时
  41           */
  42          void tmr2_enable(void)
  43          {
  44   1          // 重新给TMR2配置时钟
  45   1          TMR2_CONL &= ~(TMR_SOURCE_SEL(0x07)); // 清除定时器的时钟源配置寄存器
  46   1          TMR2_CONL |= TMR_SOURCE_SEL(0x06);    // 配置定时器的时钟源，使用系统时钟
  47   1      
  48   1          __EnableIRQ(TMR2_IRQn); // 使能中断
  49   1          IE_EA = 1;              // 打开总中断
  50   1      }
  51          
  52          /**
C51 COMPILER V9.60.7.0   TMR2                                                              11/18/2024 17:39:06 PAGE 2   

  53           * @brief 关闭定时器，清空计数值
  54           */
  55          void tmr2_disable(void)
  56          {
  57   1          // 不给定时器提供时钟，让它停止计数
  58   1          TMR2_CONL &= ~(TMR_SOURCE_SEL(0x07)); // 清除定时器的时钟源配置寄存器
  59   1          TMR2_CONL |= TMR_SOURCE_SEL(0x05);    // 配置定时器的时钟源，不用任何时钟
  60   1      
  61   1          // 清除定时器的计数值
  62   1          TMR2_CNTL = 0;
  63   1          TMR2_CNTH = 0;
  64   1      
  65   1          __DisableIRQ(TMR2_IRQn); // 关闭中断（不使能中断）
  66   1      }
  67          
  68          // TMR2中断服务函数
  69          void TIMR2_IRQHandler(void) interrupt TMR2_IRQn
  70          {
  71   1          // 进入中断设置IP，不可删除
  72   1          __IRQnIPnPush(TMR2_IRQn);
  73   1          // ---------------- 用户函数处理 -------------------
  74   1          // 周期中断
  75   1          if (TMR2_CONH & TMR_PRD_PND(0x1))
  76   1          {
  77   2              TMR2_CONH |= TMR_PRD_PND(0x1); // 清除pending
  78   2              tmr2_cnt++;
  79   2          }
  80   1      
  81   1          // 退出中断设置IP，不可删除
  82   1          __IRQnIPnPop(TMR2_IRQn);
  83   1      }
  84          
  85          #if USE_TMR2
              
              // volatile unsigned char tmr2_flag = 0; // tmr2中断服务函数中会置位的标志位
              volatile u32 tmr2_cnt = 0; // 定时器TMR2的计数值（每次在中断服务函数中会加一）
              
              /**
               * @brief 配置定时器TMR2
               */
              void tmr2_config(void)
              {
                  // 配置定时器，用来记录RF接收到的高电平持续时间
                  __SetIRQnIP(TMR2_IRQn, TMR2_IQn_CFG); // 设置中断优先级（TMR2）
              
                  TMR2_CONL &= ~TMR_PRESCALE_SEL(0x03); // 清除TMR2的预分频配置寄存器
                  // 配置TMR2的预分频，为32分频，即21MHz / 32 = 0.67MHz，约0.67us计数一次
                  // （实际测试和计算得出这个系统时钟是21MHz的，但是还是有些误差，不是准
             -的21MHz）
                  TMR2_CONL |= TMR_PRESCALE_SEL(0x05);
                  TMR2_CONL &= ~TMR_MODE_SEL(0x03); // 清除TMR2的模式配置寄存器
                  TMR2_CONL |= TMR_MODE_SEL(0x01);  // 配置TMR2的模式为计数器模式，最后对系统时钟的
             -冲进行计数
              
                  TMR2_CONH &= ~TMR_PRD_PND(0x01); // 清除TMR2的计数标志位，表示未完成计数
                  TMR2_CONH |= TMR_PRD_IRQ_EN(1);  // 使能TMR2的计数中断
              
                  // 配置TMR2的计数周期
                  TMR2_PRL = (unsigned char)(TMR2_CNT_TIME % 255);
                  TMR2_PRH = (unsigned char)(TMR2_CNT_TIME / 255);
              
                  // 清除TMR2的计数值
C51 COMPILER V9.60.7.0   TMR2                                                              11/18/2024 17:39:06 PAGE 3   

                  TMR2_CNTL = 0;
                  TMR2_CNTH = 0;
              
                  TMR2_CONL &= ~(TMR_SOURCE_SEL(0x07)); // 清除TMR2的时钟源配置寄存器
                  // TMR2_CONL |= TMR_SOURCE_SEL(0x07); // 配置TMR2的时钟源，使用系统时钟
                  TMR2_CONL |= TMR_SOURCE_SEL(0x05); // 配置TMR2的时钟源，不用任何时钟
                                                     // __EnableIRQ(TMR2_IRQn);                          // 使能中断
              
                  __DisableIRQ(TMR2_IRQn); // 禁用中断
                  IE_EA = 1;               // 打开总中断
              }
              
              /**
               * @brief 开启定时器TMR2，开始计时
               */
              void tmr2_enable(void)
              {
                  // 重新给TMR2配置时钟
                  TMR2_CONL &= ~(TMR_SOURCE_SEL(0x07)); // 清除定时器的时钟源配置寄存器
                  TMR2_CONL |= TMR_SOURCE_SEL(0x06);    // 配置定时器的时钟源，使用系统时钟（约21MHz
             -
              
                  __EnableIRQ(TMR2_IRQn); // 使能中断
                  IE_EA = 1;              // 打开总中断
              }
              
              /**
               * @brief 关闭定时器2，清空计数值
               */
              void tmr2_disable(void)
              {
                  // 不给定时器提供时钟，让它停止计数
                  TMR2_CONL &= ~(TMR_SOURCE_SEL(0x07)); // 清除定时器的时钟源配置寄存器
                  TMR2_CONL |= TMR_SOURCE_SEL(0x05);    // 配置定时器的时钟源，不用任何时钟
              
                  // 清除定时器的计数值
                  TMR2_CNTL = 0;
                  TMR2_CNTH = 0;
              
                  __DisableIRQ(TMR2_IRQn); // 关闭中断（不使能中断）
              }
              
              // 定时器配置成PWM输出模式（调用该函数前，要先将对应的IO复用到定时器的PWM
             -出上）
              void tmr2_pwm_config(void)
              {
                  //  配置P24为timer2的PWM输出端口
                  P2_MD1 &= ~GPIO_P24_MODE_SEL(0x3); // 清零
                  P2_MD1 |= GPIO_P24_MODE_SEL(0x1);  // 输出模式
                  FOUT_S24 = GPIO_FOUT_TMR2_PWMOUT;  // 复用成TMR的PWM输出
              
              // #define PEROID_VAL (SYSCLK / 128 / 10000 - 1) // 周期值=系统时钟/分频/频率 - 1     // 10KHz
              #define PEROID_VAL (SYSCLK / 128 / 1000 - 1) // 周期值=系统时钟/分频/频率 - 1     // 1KHz
                  // #define PEROID_VAL (SYSCLK / 128 / 100 - 1) // 周期值=系统时钟/分频/频率 - 1     // 100H
             -z
                  // #define PEROID_VAL (SYSCLK / 128 / 10 - 1) // 周期值=系统时钟/分频/频率 - 1     // 10Hz
              
                  // 配置频率为1kHZ，50%占空比的PWM    PWM频率=系统时钟/分频/(周期值+1)
                  TMR_ALLCON = TMR2_CNT_CLR(0x1);                        // 清除计数值
                  TMR2_PRH = TMR_PERIOD_VAL_H((PEROID_VAL >> 8) & 0xFF); // 周期值
                  TMR2_PRL = TMR_PERIOD_VAL_L((PEROID_VAL >> 0) & 0xFF);
                  TMR2_PWMH = TMR_PWM_VAL_H(((PEROID_VAL / 2) >> 8) & 0xFF); // 占空比设置值
C51 COMPILER V9.60.7.0   TMR2                                                              11/18/2024 17:39:06 PAGE 4   

                  TMR2_PWML = TMR_PWM_VAL_L(((PEROID_VAL / 2) >> 0) & 0xFF);
                  TMR2_CONH = TMR_PRD_PND(0x1) | TMR_PRD_IRQ_EN(0x1);                          // 使能计数中断
                  TMR2_CONL = TMR_SOURCE_SEL(0x7) | TMR_PRESCALE_SEL(0x7) | TMR_MODE_SEL(0x2); // 选择系统时钟，1
             -28分频，PWM模式
              }
              
              // TMR2中断服务函数
              void TIMR2_IRQHandler(void) interrupt TMR2_IRQn
              {
              #if 1 // 定时器的定时中断
                  // 进入中断设置IP，不可删除
                  __IRQnIPnPush(TMR2_IRQn);
              
                  // ---------------- 用户函数处理 -------------------
              
                  // 周期中断
                  if (TMR2_CONH & TMR_PRD_PND(0x1))
                  {
                      TMR2_CONH |= TMR_PRD_PND(0x1); // 清除pending
              
                      tmr2_cnt++; // 每5ms加一次
                  }
              
                  // 退出中断设置IP，不可删除
                  __IRQnIPnPop(TMR2_IRQn);
              #endif
              }
              #endif // USE_TMR2


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    188    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      4    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
